// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/accountbalances"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/accountdetails"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/accountflags"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/accounts"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/banners"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/debitcarddesign"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/debitcarddetails"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/debitcards"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/debitcardstatus"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/predicate"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/transactions"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/usergreetings"
	"github.com/mnsv1511/kasikorn-line-assignment/ent/users"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccountBalances  = "AccountBalances"
	TypeAccountDetails   = "AccountDetails"
	TypeAccountFlags     = "AccountFlags"
	TypeAccounts         = "Accounts"
	TypeBanners          = "Banners"
	TypeDebitCardDesign  = "DebitCardDesign"
	TypeDebitCardDetails = "DebitCardDetails"
	TypeDebitCardStatus  = "DebitCardStatus"
	TypeDebitCards       = "DebitCards"
	TypeTransactions     = "Transactions"
	TypeUserGreetings    = "UserGreetings"
	TypeUsers            = "Users"
)

// AccountBalancesMutation represents an operation that mutates the AccountBalances nodes in the graph.
type AccountBalancesMutation struct {
	config
	op              Op
	typ             string
	id              *int
	amount          *float64
	addamount       *float64
	clearedFields   map[string]struct{}
	users           *int
	clearedusers    bool
	accounts        *int
	clearedaccounts bool
	done            bool
	oldValue        func(context.Context) (*AccountBalances, error)
	predicates      []predicate.AccountBalances
}

var _ ent.Mutation = (*AccountBalancesMutation)(nil)

// accountbalancesOption allows management of the mutation configuration using functional options.
type accountbalancesOption func(*AccountBalancesMutation)

// newAccountBalancesMutation creates new mutation for the AccountBalances entity.
func newAccountBalancesMutation(c config, op Op, opts ...accountbalancesOption) *AccountBalancesMutation {
	m := &AccountBalancesMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountBalances,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountBalancesID sets the ID field of the mutation.
func withAccountBalancesID(id int) accountbalancesOption {
	return func(m *AccountBalancesMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountBalances
		)
		m.oldValue = func(ctx context.Context) (*AccountBalances, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountBalances.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountBalances sets the old AccountBalances of the mutation.
func withAccountBalances(node *AccountBalances) accountbalancesOption {
	return func(m *AccountBalancesMutation) {
		m.oldValue = func(context.Context) (*AccountBalances, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountBalancesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountBalancesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountBalancesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountBalancesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountBalances.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccountID sets the "account_id" field.
func (m *AccountBalancesMutation) SetAccountID(i int) {
	m.accounts = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AccountBalancesMutation) AccountID() (r int, exists bool) {
	v := m.accounts
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the AccountBalances entity.
// If the AccountBalances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountBalancesMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *AccountBalancesMutation) ClearAccountID() {
	m.accounts = nil
	m.clearedFields[accountbalances.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *AccountBalancesMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[accountbalances.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AccountBalancesMutation) ResetAccountID() {
	m.accounts = nil
	delete(m.clearedFields, accountbalances.FieldAccountID)
}

// SetUserID sets the "user_id" field.
func (m *AccountBalancesMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountBalancesMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AccountBalances entity.
// If the AccountBalances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountBalancesMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AccountBalancesMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[accountbalances.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AccountBalancesMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[accountbalances.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountBalancesMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, accountbalances.FieldUserID)
}

// SetAmount sets the "amount" field.
func (m *AccountBalancesMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AccountBalancesMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the AccountBalances entity.
// If the AccountBalances object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountBalancesMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *AccountBalancesMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AccountBalancesMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *AccountBalancesMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetUsersID sets the "users" edge to the Users entity by id.
func (m *AccountBalancesMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *AccountBalancesMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[accountbalances.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *AccountBalancesMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *AccountBalancesMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *AccountBalancesMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AccountBalancesMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// SetAccountsID sets the "accounts" edge to the Accounts entity by id.
func (m *AccountBalancesMutation) SetAccountsID(id int) {
	m.accounts = &id
}

// ClearAccounts clears the "accounts" edge to the Accounts entity.
func (m *AccountBalancesMutation) ClearAccounts() {
	m.clearedaccounts = true
	m.clearedFields[accountbalances.FieldAccountID] = struct{}{}
}

// AccountsCleared reports if the "accounts" edge to the Accounts entity was cleared.
func (m *AccountBalancesMutation) AccountsCleared() bool {
	return m.AccountIDCleared() || m.clearedaccounts
}

// AccountsID returns the "accounts" edge ID in the mutation.
func (m *AccountBalancesMutation) AccountsID() (id int, exists bool) {
	if m.accounts != nil {
		return *m.accounts, true
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountsID instead. It exists only for internal usage by the builders.
func (m *AccountBalancesMutation) AccountsIDs() (ids []int) {
	if id := m.accounts; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *AccountBalancesMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
}

// Where appends a list predicates to the AccountBalancesMutation builder.
func (m *AccountBalancesMutation) Where(ps ...predicate.AccountBalances) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountBalancesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountBalancesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountBalances, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountBalancesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountBalancesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountBalances).
func (m *AccountBalancesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountBalancesMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.accounts != nil {
		fields = append(fields, accountbalances.FieldAccountID)
	}
	if m.users != nil {
		fields = append(fields, accountbalances.FieldUserID)
	}
	if m.amount != nil {
		fields = append(fields, accountbalances.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountBalancesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountbalances.FieldAccountID:
		return m.AccountID()
	case accountbalances.FieldUserID:
		return m.UserID()
	case accountbalances.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountBalancesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountbalances.FieldAccountID:
		return m.OldAccountID(ctx)
	case accountbalances.FieldUserID:
		return m.OldUserID(ctx)
	case accountbalances.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown AccountBalances field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountBalancesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountbalances.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case accountbalances.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case accountbalances.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown AccountBalances field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountBalancesMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, accountbalances.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountBalancesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountbalances.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountBalancesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountbalances.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown AccountBalances numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountBalancesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountbalances.FieldAccountID) {
		fields = append(fields, accountbalances.FieldAccountID)
	}
	if m.FieldCleared(accountbalances.FieldUserID) {
		fields = append(fields, accountbalances.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountBalancesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountBalancesMutation) ClearField(name string) error {
	switch name {
	case accountbalances.FieldAccountID:
		m.ClearAccountID()
		return nil
	case accountbalances.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown AccountBalances nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountBalancesMutation) ResetField(name string) error {
	switch name {
	case accountbalances.FieldAccountID:
		m.ResetAccountID()
		return nil
	case accountbalances.FieldUserID:
		m.ResetUserID()
		return nil
	case accountbalances.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown AccountBalances field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountBalancesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, accountbalances.EdgeUsers)
	}
	if m.accounts != nil {
		edges = append(edges, accountbalances.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountBalancesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountbalances.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case accountbalances.EdgeAccounts:
		if id := m.accounts; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountBalancesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountBalancesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountBalancesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, accountbalances.EdgeUsers)
	}
	if m.clearedaccounts {
		edges = append(edges, accountbalances.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountBalancesMutation) EdgeCleared(name string) bool {
	switch name {
	case accountbalances.EdgeUsers:
		return m.clearedusers
	case accountbalances.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountBalancesMutation) ClearEdge(name string) error {
	switch name {
	case accountbalances.EdgeUsers:
		m.ClearUsers()
		return nil
	case accountbalances.EdgeAccounts:
		m.ClearAccounts()
		return nil
	}
	return fmt.Errorf("unknown AccountBalances unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountBalancesMutation) ResetEdge(name string) error {
	switch name {
	case accountbalances.EdgeUsers:
		m.ResetUsers()
		return nil
	case accountbalances.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown AccountBalances edge %s", name)
}

// AccountDetailsMutation represents an operation that mutates the AccountDetails nodes in the graph.
type AccountDetailsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	color           *string
	is_main_account *bool
	progress        *int
	addprogress     *int
	name            *string
	clearedFields   map[string]struct{}
	users           *int
	clearedusers    bool
	accounts        *int
	clearedaccounts bool
	done            bool
	oldValue        func(context.Context) (*AccountDetails, error)
	predicates      []predicate.AccountDetails
}

var _ ent.Mutation = (*AccountDetailsMutation)(nil)

// accountdetailsOption allows management of the mutation configuration using functional options.
type accountdetailsOption func(*AccountDetailsMutation)

// newAccountDetailsMutation creates new mutation for the AccountDetails entity.
func newAccountDetailsMutation(c config, op Op, opts ...accountdetailsOption) *AccountDetailsMutation {
	m := &AccountDetailsMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountDetails,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountDetailsID sets the ID field of the mutation.
func withAccountDetailsID(id int) accountdetailsOption {
	return func(m *AccountDetailsMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountDetails
		)
		m.oldValue = func(ctx context.Context) (*AccountDetails, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountDetails.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountDetails sets the old AccountDetails of the mutation.
func withAccountDetails(node *AccountDetails) accountdetailsOption {
	return func(m *AccountDetailsMutation) {
		m.oldValue = func(context.Context) (*AccountDetails, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountDetailsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountDetailsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountDetailsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountDetailsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountDetails.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccountID sets the "account_id" field.
func (m *AccountDetailsMutation) SetAccountID(i int) {
	m.accounts = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AccountDetailsMutation) AccountID() (r int, exists bool) {
	v := m.accounts
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the AccountDetails entity.
// If the AccountDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountDetailsMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *AccountDetailsMutation) ClearAccountID() {
	m.accounts = nil
	m.clearedFields[accountdetails.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *AccountDetailsMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[accountdetails.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AccountDetailsMutation) ResetAccountID() {
	m.accounts = nil
	delete(m.clearedFields, accountdetails.FieldAccountID)
}

// SetUserID sets the "user_id" field.
func (m *AccountDetailsMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountDetailsMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AccountDetails entity.
// If the AccountDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountDetailsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AccountDetailsMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[accountdetails.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AccountDetailsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[accountdetails.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountDetailsMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, accountdetails.FieldUserID)
}

// SetColor sets the "color" field.
func (m *AccountDetailsMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *AccountDetailsMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the AccountDetails entity.
// If the AccountDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountDetailsMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *AccountDetailsMutation) ResetColor() {
	m.color = nil
}

// SetIsMainAccount sets the "is_main_account" field.
func (m *AccountDetailsMutation) SetIsMainAccount(b bool) {
	m.is_main_account = &b
}

// IsMainAccount returns the value of the "is_main_account" field in the mutation.
func (m *AccountDetailsMutation) IsMainAccount() (r bool, exists bool) {
	v := m.is_main_account
	if v == nil {
		return
	}
	return *v, true
}

// OldIsMainAccount returns the old "is_main_account" field's value of the AccountDetails entity.
// If the AccountDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountDetailsMutation) OldIsMainAccount(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsMainAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsMainAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsMainAccount: %w", err)
	}
	return oldValue.IsMainAccount, nil
}

// ResetIsMainAccount resets all changes to the "is_main_account" field.
func (m *AccountDetailsMutation) ResetIsMainAccount() {
	m.is_main_account = nil
}

// SetProgress sets the "progress" field.
func (m *AccountDetailsMutation) SetProgress(i int) {
	m.progress = &i
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *AccountDetailsMutation) Progress() (r int, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the AccountDetails entity.
// If the AccountDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountDetailsMutation) OldProgress(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds i to the "progress" field.
func (m *AccountDetailsMutation) AddProgress(i int) {
	if m.addprogress != nil {
		*m.addprogress += i
	} else {
		m.addprogress = &i
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *AccountDetailsMutation) AddedProgress() (r int, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *AccountDetailsMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetName sets the "name" field.
func (m *AccountDetailsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountDetailsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AccountDetails entity.
// If the AccountDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountDetailsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountDetailsMutation) ResetName() {
	m.name = nil
}

// SetUsersID sets the "users" edge to the Users entity by id.
func (m *AccountDetailsMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *AccountDetailsMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[accountdetails.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *AccountDetailsMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *AccountDetailsMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *AccountDetailsMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AccountDetailsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// SetAccountsID sets the "accounts" edge to the Accounts entity by id.
func (m *AccountDetailsMutation) SetAccountsID(id int) {
	m.accounts = &id
}

// ClearAccounts clears the "accounts" edge to the Accounts entity.
func (m *AccountDetailsMutation) ClearAccounts() {
	m.clearedaccounts = true
	m.clearedFields[accountdetails.FieldAccountID] = struct{}{}
}

// AccountsCleared reports if the "accounts" edge to the Accounts entity was cleared.
func (m *AccountDetailsMutation) AccountsCleared() bool {
	return m.AccountIDCleared() || m.clearedaccounts
}

// AccountsID returns the "accounts" edge ID in the mutation.
func (m *AccountDetailsMutation) AccountsID() (id int, exists bool) {
	if m.accounts != nil {
		return *m.accounts, true
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountsID instead. It exists only for internal usage by the builders.
func (m *AccountDetailsMutation) AccountsIDs() (ids []int) {
	if id := m.accounts; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *AccountDetailsMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
}

// Where appends a list predicates to the AccountDetailsMutation builder.
func (m *AccountDetailsMutation) Where(ps ...predicate.AccountDetails) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountDetailsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountDetailsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountDetails, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountDetailsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountDetailsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountDetails).
func (m *AccountDetailsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountDetailsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.accounts != nil {
		fields = append(fields, accountdetails.FieldAccountID)
	}
	if m.users != nil {
		fields = append(fields, accountdetails.FieldUserID)
	}
	if m.color != nil {
		fields = append(fields, accountdetails.FieldColor)
	}
	if m.is_main_account != nil {
		fields = append(fields, accountdetails.FieldIsMainAccount)
	}
	if m.progress != nil {
		fields = append(fields, accountdetails.FieldProgress)
	}
	if m.name != nil {
		fields = append(fields, accountdetails.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountDetailsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountdetails.FieldAccountID:
		return m.AccountID()
	case accountdetails.FieldUserID:
		return m.UserID()
	case accountdetails.FieldColor:
		return m.Color()
	case accountdetails.FieldIsMainAccount:
		return m.IsMainAccount()
	case accountdetails.FieldProgress:
		return m.Progress()
	case accountdetails.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountDetailsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountdetails.FieldAccountID:
		return m.OldAccountID(ctx)
	case accountdetails.FieldUserID:
		return m.OldUserID(ctx)
	case accountdetails.FieldColor:
		return m.OldColor(ctx)
	case accountdetails.FieldIsMainAccount:
		return m.OldIsMainAccount(ctx)
	case accountdetails.FieldProgress:
		return m.OldProgress(ctx)
	case accountdetails.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown AccountDetails field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountDetailsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountdetails.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case accountdetails.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case accountdetails.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case accountdetails.FieldIsMainAccount:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsMainAccount(v)
		return nil
	case accountdetails.FieldProgress:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case accountdetails.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown AccountDetails field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountDetailsMutation) AddedFields() []string {
	var fields []string
	if m.addprogress != nil {
		fields = append(fields, accountdetails.FieldProgress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountDetailsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountdetails.FieldProgress:
		return m.AddedProgress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountDetailsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountdetails.FieldProgress:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	}
	return fmt.Errorf("unknown AccountDetails numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountDetailsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountdetails.FieldAccountID) {
		fields = append(fields, accountdetails.FieldAccountID)
	}
	if m.FieldCleared(accountdetails.FieldUserID) {
		fields = append(fields, accountdetails.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountDetailsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountDetailsMutation) ClearField(name string) error {
	switch name {
	case accountdetails.FieldAccountID:
		m.ClearAccountID()
		return nil
	case accountdetails.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown AccountDetails nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountDetailsMutation) ResetField(name string) error {
	switch name {
	case accountdetails.FieldAccountID:
		m.ResetAccountID()
		return nil
	case accountdetails.FieldUserID:
		m.ResetUserID()
		return nil
	case accountdetails.FieldColor:
		m.ResetColor()
		return nil
	case accountdetails.FieldIsMainAccount:
		m.ResetIsMainAccount()
		return nil
	case accountdetails.FieldProgress:
		m.ResetProgress()
		return nil
	case accountdetails.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown AccountDetails field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountDetailsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, accountdetails.EdgeUsers)
	}
	if m.accounts != nil {
		edges = append(edges, accountdetails.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountDetailsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountdetails.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case accountdetails.EdgeAccounts:
		if id := m.accounts; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountDetailsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountDetailsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountDetailsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, accountdetails.EdgeUsers)
	}
	if m.clearedaccounts {
		edges = append(edges, accountdetails.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountDetailsMutation) EdgeCleared(name string) bool {
	switch name {
	case accountdetails.EdgeUsers:
		return m.clearedusers
	case accountdetails.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountDetailsMutation) ClearEdge(name string) error {
	switch name {
	case accountdetails.EdgeUsers:
		m.ClearUsers()
		return nil
	case accountdetails.EdgeAccounts:
		m.ClearAccounts()
		return nil
	}
	return fmt.Errorf("unknown AccountDetails unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountDetailsMutation) ResetEdge(name string) error {
	switch name {
	case accountdetails.EdgeUsers:
		m.ResetUsers()
		return nil
	case accountdetails.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown AccountDetails edge %s", name)
}

// AccountFlagsMutation represents an operation that mutates the AccountFlags nodes in the graph.
type AccountFlagsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	flag_type       *string
	flag_value      *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	users           *int
	clearedusers    bool
	accounts        *int
	clearedaccounts bool
	done            bool
	oldValue        func(context.Context) (*AccountFlags, error)
	predicates      []predicate.AccountFlags
}

var _ ent.Mutation = (*AccountFlagsMutation)(nil)

// accountflagsOption allows management of the mutation configuration using functional options.
type accountflagsOption func(*AccountFlagsMutation)

// newAccountFlagsMutation creates new mutation for the AccountFlags entity.
func newAccountFlagsMutation(c config, op Op, opts ...accountflagsOption) *AccountFlagsMutation {
	m := &AccountFlagsMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountFlags,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountFlagsID sets the ID field of the mutation.
func withAccountFlagsID(id int) accountflagsOption {
	return func(m *AccountFlagsMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountFlags
		)
		m.oldValue = func(ctx context.Context) (*AccountFlags, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountFlags.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountFlags sets the old AccountFlags of the mutation.
func withAccountFlags(node *AccountFlags) accountflagsOption {
	return func(m *AccountFlagsMutation) {
		m.oldValue = func(context.Context) (*AccountFlags, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountFlagsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountFlagsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountFlagsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountFlagsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountFlags.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccountID sets the "account_id" field.
func (m *AccountFlagsMutation) SetAccountID(i int) {
	m.accounts = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AccountFlagsMutation) AccountID() (r int, exists bool) {
	v := m.accounts
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the AccountFlags entity.
// If the AccountFlags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFlagsMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *AccountFlagsMutation) ClearAccountID() {
	m.accounts = nil
	m.clearedFields[accountflags.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *AccountFlagsMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[accountflags.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AccountFlagsMutation) ResetAccountID() {
	m.accounts = nil
	delete(m.clearedFields, accountflags.FieldAccountID)
}

// SetUserID sets the "user_id" field.
func (m *AccountFlagsMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountFlagsMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AccountFlags entity.
// If the AccountFlags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFlagsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AccountFlagsMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[accountflags.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AccountFlagsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[accountflags.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountFlagsMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, accountflags.FieldUserID)
}

// SetFlagType sets the "flag_type" field.
func (m *AccountFlagsMutation) SetFlagType(s string) {
	m.flag_type = &s
}

// FlagType returns the value of the "flag_type" field in the mutation.
func (m *AccountFlagsMutation) FlagType() (r string, exists bool) {
	v := m.flag_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFlagType returns the old "flag_type" field's value of the AccountFlags entity.
// If the AccountFlags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFlagsMutation) OldFlagType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlagType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlagType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlagType: %w", err)
	}
	return oldValue.FlagType, nil
}

// ResetFlagType resets all changes to the "flag_type" field.
func (m *AccountFlagsMutation) ResetFlagType() {
	m.flag_type = nil
}

// SetFlagValue sets the "flag_value" field.
func (m *AccountFlagsMutation) SetFlagValue(s string) {
	m.flag_value = &s
}

// FlagValue returns the value of the "flag_value" field in the mutation.
func (m *AccountFlagsMutation) FlagValue() (r string, exists bool) {
	v := m.flag_value
	if v == nil {
		return
	}
	return *v, true
}

// OldFlagValue returns the old "flag_value" field's value of the AccountFlags entity.
// If the AccountFlags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFlagsMutation) OldFlagValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlagValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlagValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlagValue: %w", err)
	}
	return oldValue.FlagValue, nil
}

// ResetFlagValue resets all changes to the "flag_value" field.
func (m *AccountFlagsMutation) ResetFlagValue() {
	m.flag_value = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountFlagsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountFlagsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountFlags entity.
// If the AccountFlags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFlagsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountFlagsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountFlagsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountFlagsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccountFlags entity.
// If the AccountFlags object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountFlagsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountFlagsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsersID sets the "users" edge to the Users entity by id.
func (m *AccountFlagsMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *AccountFlagsMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[accountflags.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *AccountFlagsMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *AccountFlagsMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *AccountFlagsMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AccountFlagsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// SetAccountsID sets the "accounts" edge to the Accounts entity by id.
func (m *AccountFlagsMutation) SetAccountsID(id int) {
	m.accounts = &id
}

// ClearAccounts clears the "accounts" edge to the Accounts entity.
func (m *AccountFlagsMutation) ClearAccounts() {
	m.clearedaccounts = true
	m.clearedFields[accountflags.FieldAccountID] = struct{}{}
}

// AccountsCleared reports if the "accounts" edge to the Accounts entity was cleared.
func (m *AccountFlagsMutation) AccountsCleared() bool {
	return m.AccountIDCleared() || m.clearedaccounts
}

// AccountsID returns the "accounts" edge ID in the mutation.
func (m *AccountFlagsMutation) AccountsID() (id int, exists bool) {
	if m.accounts != nil {
		return *m.accounts, true
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountsID instead. It exists only for internal usage by the builders.
func (m *AccountFlagsMutation) AccountsIDs() (ids []int) {
	if id := m.accounts; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *AccountFlagsMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
}

// Where appends a list predicates to the AccountFlagsMutation builder.
func (m *AccountFlagsMutation) Where(ps ...predicate.AccountFlags) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountFlagsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountFlagsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountFlags, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountFlagsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountFlagsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountFlags).
func (m *AccountFlagsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountFlagsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.accounts != nil {
		fields = append(fields, accountflags.FieldAccountID)
	}
	if m.users != nil {
		fields = append(fields, accountflags.FieldUserID)
	}
	if m.flag_type != nil {
		fields = append(fields, accountflags.FieldFlagType)
	}
	if m.flag_value != nil {
		fields = append(fields, accountflags.FieldFlagValue)
	}
	if m.created_at != nil {
		fields = append(fields, accountflags.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accountflags.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountFlagsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountflags.FieldAccountID:
		return m.AccountID()
	case accountflags.FieldUserID:
		return m.UserID()
	case accountflags.FieldFlagType:
		return m.FlagType()
	case accountflags.FieldFlagValue:
		return m.FlagValue()
	case accountflags.FieldCreatedAt:
		return m.CreatedAt()
	case accountflags.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountFlagsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountflags.FieldAccountID:
		return m.OldAccountID(ctx)
	case accountflags.FieldUserID:
		return m.OldUserID(ctx)
	case accountflags.FieldFlagType:
		return m.OldFlagType(ctx)
	case accountflags.FieldFlagValue:
		return m.OldFlagValue(ctx)
	case accountflags.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountflags.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AccountFlags field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountFlagsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountflags.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case accountflags.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case accountflags.FieldFlagType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlagType(v)
		return nil
	case accountflags.FieldFlagValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlagValue(v)
		return nil
	case accountflags.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountflags.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AccountFlags field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountFlagsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountFlagsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountFlagsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccountFlags numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountFlagsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountflags.FieldAccountID) {
		fields = append(fields, accountflags.FieldAccountID)
	}
	if m.FieldCleared(accountflags.FieldUserID) {
		fields = append(fields, accountflags.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountFlagsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountFlagsMutation) ClearField(name string) error {
	switch name {
	case accountflags.FieldAccountID:
		m.ClearAccountID()
		return nil
	case accountflags.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown AccountFlags nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountFlagsMutation) ResetField(name string) error {
	switch name {
	case accountflags.FieldAccountID:
		m.ResetAccountID()
		return nil
	case accountflags.FieldUserID:
		m.ResetUserID()
		return nil
	case accountflags.FieldFlagType:
		m.ResetFlagType()
		return nil
	case accountflags.FieldFlagValue:
		m.ResetFlagValue()
		return nil
	case accountflags.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountflags.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AccountFlags field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountFlagsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, accountflags.EdgeUsers)
	}
	if m.accounts != nil {
		edges = append(edges, accountflags.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountFlagsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountflags.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case accountflags.EdgeAccounts:
		if id := m.accounts; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountFlagsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountFlagsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountFlagsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, accountflags.EdgeUsers)
	}
	if m.clearedaccounts {
		edges = append(edges, accountflags.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountFlagsMutation) EdgeCleared(name string) bool {
	switch name {
	case accountflags.EdgeUsers:
		return m.clearedusers
	case accountflags.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountFlagsMutation) ClearEdge(name string) error {
	switch name {
	case accountflags.EdgeUsers:
		m.ClearUsers()
		return nil
	case accountflags.EdgeAccounts:
		m.ClearAccounts()
		return nil
	}
	return fmt.Errorf("unknown AccountFlags unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountFlagsMutation) ResetEdge(name string) error {
	switch name {
	case accountflags.EdgeUsers:
		m.ResetUsers()
		return nil
	case accountflags.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown AccountFlags edge %s", name)
}

// AccountsMutation represents an operation that mutates the Accounts nodes in the graph.
type AccountsMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	_type                   *string
	currency                *string
	account_number          *string
	issuer                  *string
	clearedFields           map[string]struct{}
	account_balances        map[int]struct{}
	removedaccount_balances map[int]struct{}
	clearedaccount_balances bool
	account_details         map[int]struct{}
	removedaccount_details  map[int]struct{}
	clearedaccount_details  bool
	account_flags           map[int]struct{}
	removedaccount_flags    map[int]struct{}
	clearedaccount_flags    bool
	users                   *int
	clearedusers            bool
	done                    bool
	oldValue                func(context.Context) (*Accounts, error)
	predicates              []predicate.Accounts
}

var _ ent.Mutation = (*AccountsMutation)(nil)

// accountsOption allows management of the mutation configuration using functional options.
type accountsOption func(*AccountsMutation)

// newAccountsMutation creates new mutation for the Accounts entity.
func newAccountsMutation(c config, op Op, opts ...accountsOption) *AccountsMutation {
	m := &AccountsMutation{
		config:        c,
		op:            op,
		typ:           TypeAccounts,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountsID sets the ID field of the mutation.
func withAccountsID(id int) accountsOption {
	return func(m *AccountsMutation) {
		var (
			err   error
			once  sync.Once
			value *Accounts
		)
		m.oldValue = func(ctx context.Context) (*Accounts, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Accounts.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccounts sets the old Accounts of the mutation.
func withAccounts(node *Accounts) accountsOption {
	return func(m *AccountsMutation) {
		m.oldValue = func(context.Context) (*Accounts, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Accounts.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AccountsMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountsMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AccountsMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[accounts.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AccountsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[accounts.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountsMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, accounts.FieldUserID)
}

// SetType sets the "type" field.
func (m *AccountsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AccountsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AccountsMutation) ResetType() {
	m._type = nil
}

// SetCurrency sets the "currency" field.
func (m *AccountsMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *AccountsMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *AccountsMutation) ResetCurrency() {
	m.currency = nil
}

// SetAccountNumber sets the "account_number" field.
func (m *AccountsMutation) SetAccountNumber(s string) {
	m.account_number = &s
}

// AccountNumber returns the value of the "account_number" field in the mutation.
func (m *AccountsMutation) AccountNumber() (r string, exists bool) {
	v := m.account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNumber returns the old "account_number" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNumber: %w", err)
	}
	return oldValue.AccountNumber, nil
}

// ResetAccountNumber resets all changes to the "account_number" field.
func (m *AccountsMutation) ResetAccountNumber() {
	m.account_number = nil
}

// SetIssuer sets the "issuer" field.
func (m *AccountsMutation) SetIssuer(s string) {
	m.issuer = &s
}

// Issuer returns the value of the "issuer" field in the mutation.
func (m *AccountsMutation) Issuer() (r string, exists bool) {
	v := m.issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuer returns the old "issuer" field's value of the Accounts entity.
// If the Accounts object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountsMutation) OldIssuer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuer: %w", err)
	}
	return oldValue.Issuer, nil
}

// ResetIssuer resets all changes to the "issuer" field.
func (m *AccountsMutation) ResetIssuer() {
	m.issuer = nil
}

// AddAccountBalanceIDs adds the "account_balances" edge to the AccountBalances entity by ids.
func (m *AccountsMutation) AddAccountBalanceIDs(ids ...int) {
	if m.account_balances == nil {
		m.account_balances = make(map[int]struct{})
	}
	for i := range ids {
		m.account_balances[ids[i]] = struct{}{}
	}
}

// ClearAccountBalances clears the "account_balances" edge to the AccountBalances entity.
func (m *AccountsMutation) ClearAccountBalances() {
	m.clearedaccount_balances = true
}

// AccountBalancesCleared reports if the "account_balances" edge to the AccountBalances entity was cleared.
func (m *AccountsMutation) AccountBalancesCleared() bool {
	return m.clearedaccount_balances
}

// RemoveAccountBalanceIDs removes the "account_balances" edge to the AccountBalances entity by IDs.
func (m *AccountsMutation) RemoveAccountBalanceIDs(ids ...int) {
	if m.removedaccount_balances == nil {
		m.removedaccount_balances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.account_balances, ids[i])
		m.removedaccount_balances[ids[i]] = struct{}{}
	}
}

// RemovedAccountBalances returns the removed IDs of the "account_balances" edge to the AccountBalances entity.
func (m *AccountsMutation) RemovedAccountBalancesIDs() (ids []int) {
	for id := range m.removedaccount_balances {
		ids = append(ids, id)
	}
	return
}

// AccountBalancesIDs returns the "account_balances" edge IDs in the mutation.
func (m *AccountsMutation) AccountBalancesIDs() (ids []int) {
	for id := range m.account_balances {
		ids = append(ids, id)
	}
	return
}

// ResetAccountBalances resets all changes to the "account_balances" edge.
func (m *AccountsMutation) ResetAccountBalances() {
	m.account_balances = nil
	m.clearedaccount_balances = false
	m.removedaccount_balances = nil
}

// AddAccountDetailIDs adds the "account_details" edge to the AccountDetails entity by ids.
func (m *AccountsMutation) AddAccountDetailIDs(ids ...int) {
	if m.account_details == nil {
		m.account_details = make(map[int]struct{})
	}
	for i := range ids {
		m.account_details[ids[i]] = struct{}{}
	}
}

// ClearAccountDetails clears the "account_details" edge to the AccountDetails entity.
func (m *AccountsMutation) ClearAccountDetails() {
	m.clearedaccount_details = true
}

// AccountDetailsCleared reports if the "account_details" edge to the AccountDetails entity was cleared.
func (m *AccountsMutation) AccountDetailsCleared() bool {
	return m.clearedaccount_details
}

// RemoveAccountDetailIDs removes the "account_details" edge to the AccountDetails entity by IDs.
func (m *AccountsMutation) RemoveAccountDetailIDs(ids ...int) {
	if m.removedaccount_details == nil {
		m.removedaccount_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.account_details, ids[i])
		m.removedaccount_details[ids[i]] = struct{}{}
	}
}

// RemovedAccountDetails returns the removed IDs of the "account_details" edge to the AccountDetails entity.
func (m *AccountsMutation) RemovedAccountDetailsIDs() (ids []int) {
	for id := range m.removedaccount_details {
		ids = append(ids, id)
	}
	return
}

// AccountDetailsIDs returns the "account_details" edge IDs in the mutation.
func (m *AccountsMutation) AccountDetailsIDs() (ids []int) {
	for id := range m.account_details {
		ids = append(ids, id)
	}
	return
}

// ResetAccountDetails resets all changes to the "account_details" edge.
func (m *AccountsMutation) ResetAccountDetails() {
	m.account_details = nil
	m.clearedaccount_details = false
	m.removedaccount_details = nil
}

// AddAccountFlagIDs adds the "account_flags" edge to the AccountFlags entity by ids.
func (m *AccountsMutation) AddAccountFlagIDs(ids ...int) {
	if m.account_flags == nil {
		m.account_flags = make(map[int]struct{})
	}
	for i := range ids {
		m.account_flags[ids[i]] = struct{}{}
	}
}

// ClearAccountFlags clears the "account_flags" edge to the AccountFlags entity.
func (m *AccountsMutation) ClearAccountFlags() {
	m.clearedaccount_flags = true
}

// AccountFlagsCleared reports if the "account_flags" edge to the AccountFlags entity was cleared.
func (m *AccountsMutation) AccountFlagsCleared() bool {
	return m.clearedaccount_flags
}

// RemoveAccountFlagIDs removes the "account_flags" edge to the AccountFlags entity by IDs.
func (m *AccountsMutation) RemoveAccountFlagIDs(ids ...int) {
	if m.removedaccount_flags == nil {
		m.removedaccount_flags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.account_flags, ids[i])
		m.removedaccount_flags[ids[i]] = struct{}{}
	}
}

// RemovedAccountFlags returns the removed IDs of the "account_flags" edge to the AccountFlags entity.
func (m *AccountsMutation) RemovedAccountFlagsIDs() (ids []int) {
	for id := range m.removedaccount_flags {
		ids = append(ids, id)
	}
	return
}

// AccountFlagsIDs returns the "account_flags" edge IDs in the mutation.
func (m *AccountsMutation) AccountFlagsIDs() (ids []int) {
	for id := range m.account_flags {
		ids = append(ids, id)
	}
	return
}

// ResetAccountFlags resets all changes to the "account_flags" edge.
func (m *AccountsMutation) ResetAccountFlags() {
	m.account_flags = nil
	m.clearedaccount_flags = false
	m.removedaccount_flags = nil
}

// SetUsersID sets the "users" edge to the Users entity by id.
func (m *AccountsMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *AccountsMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[accounts.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *AccountsMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *AccountsMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *AccountsMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AccountsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the AccountsMutation builder.
func (m *AccountsMutation) Where(ps ...predicate.Accounts) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Accounts, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Accounts).
func (m *AccountsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.users != nil {
		fields = append(fields, accounts.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, accounts.FieldType)
	}
	if m.currency != nil {
		fields = append(fields, accounts.FieldCurrency)
	}
	if m.account_number != nil {
		fields = append(fields, accounts.FieldAccountNumber)
	}
	if m.issuer != nil {
		fields = append(fields, accounts.FieldIssuer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accounts.FieldUserID:
		return m.UserID()
	case accounts.FieldType:
		return m.GetType()
	case accounts.FieldCurrency:
		return m.Currency()
	case accounts.FieldAccountNumber:
		return m.AccountNumber()
	case accounts.FieldIssuer:
		return m.Issuer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accounts.FieldUserID:
		return m.OldUserID(ctx)
	case accounts.FieldType:
		return m.OldType(ctx)
	case accounts.FieldCurrency:
		return m.OldCurrency(ctx)
	case accounts.FieldAccountNumber:
		return m.OldAccountNumber(ctx)
	case accounts.FieldIssuer:
		return m.OldIssuer(ctx)
	}
	return nil, fmt.Errorf("unknown Accounts field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accounts.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case accounts.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case accounts.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case accounts.FieldAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNumber(v)
		return nil
	case accounts.FieldIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuer(v)
		return nil
	}
	return fmt.Errorf("unknown Accounts field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Accounts numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accounts.FieldUserID) {
		fields = append(fields, accounts.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountsMutation) ClearField(name string) error {
	switch name {
	case accounts.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Accounts nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountsMutation) ResetField(name string) error {
	switch name {
	case accounts.FieldUserID:
		m.ResetUserID()
		return nil
	case accounts.FieldType:
		m.ResetType()
		return nil
	case accounts.FieldCurrency:
		m.ResetCurrency()
		return nil
	case accounts.FieldAccountNumber:
		m.ResetAccountNumber()
		return nil
	case accounts.FieldIssuer:
		m.ResetIssuer()
		return nil
	}
	return fmt.Errorf("unknown Accounts field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.account_balances != nil {
		edges = append(edges, accounts.EdgeAccountBalances)
	}
	if m.account_details != nil {
		edges = append(edges, accounts.EdgeAccountDetails)
	}
	if m.account_flags != nil {
		edges = append(edges, accounts.EdgeAccountFlags)
	}
	if m.users != nil {
		edges = append(edges, accounts.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accounts.EdgeAccountBalances:
		ids := make([]ent.Value, 0, len(m.account_balances))
		for id := range m.account_balances {
			ids = append(ids, id)
		}
		return ids
	case accounts.EdgeAccountDetails:
		ids := make([]ent.Value, 0, len(m.account_details))
		for id := range m.account_details {
			ids = append(ids, id)
		}
		return ids
	case accounts.EdgeAccountFlags:
		ids := make([]ent.Value, 0, len(m.account_flags))
		for id := range m.account_flags {
			ids = append(ids, id)
		}
		return ids
	case accounts.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedaccount_balances != nil {
		edges = append(edges, accounts.EdgeAccountBalances)
	}
	if m.removedaccount_details != nil {
		edges = append(edges, accounts.EdgeAccountDetails)
	}
	if m.removedaccount_flags != nil {
		edges = append(edges, accounts.EdgeAccountFlags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case accounts.EdgeAccountBalances:
		ids := make([]ent.Value, 0, len(m.removedaccount_balances))
		for id := range m.removedaccount_balances {
			ids = append(ids, id)
		}
		return ids
	case accounts.EdgeAccountDetails:
		ids := make([]ent.Value, 0, len(m.removedaccount_details))
		for id := range m.removedaccount_details {
			ids = append(ids, id)
		}
		return ids
	case accounts.EdgeAccountFlags:
		ids := make([]ent.Value, 0, len(m.removedaccount_flags))
		for id := range m.removedaccount_flags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedaccount_balances {
		edges = append(edges, accounts.EdgeAccountBalances)
	}
	if m.clearedaccount_details {
		edges = append(edges, accounts.EdgeAccountDetails)
	}
	if m.clearedaccount_flags {
		edges = append(edges, accounts.EdgeAccountFlags)
	}
	if m.clearedusers {
		edges = append(edges, accounts.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountsMutation) EdgeCleared(name string) bool {
	switch name {
	case accounts.EdgeAccountBalances:
		return m.clearedaccount_balances
	case accounts.EdgeAccountDetails:
		return m.clearedaccount_details
	case accounts.EdgeAccountFlags:
		return m.clearedaccount_flags
	case accounts.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountsMutation) ClearEdge(name string) error {
	switch name {
	case accounts.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown Accounts unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountsMutation) ResetEdge(name string) error {
	switch name {
	case accounts.EdgeAccountBalances:
		m.ResetAccountBalances()
		return nil
	case accounts.EdgeAccountDetails:
		m.ResetAccountDetails()
		return nil
	case accounts.EdgeAccountFlags:
		m.ResetAccountFlags()
		return nil
	case accounts.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Accounts edge %s", name)
}

// BannersMutation represents an operation that mutates the Banners nodes in the graph.
type BannersMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	description   *string
	image         *string
	clearedFields map[string]struct{}
	users         *int
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Banners, error)
	predicates    []predicate.Banners
}

var _ ent.Mutation = (*BannersMutation)(nil)

// bannersOption allows management of the mutation configuration using functional options.
type bannersOption func(*BannersMutation)

// newBannersMutation creates new mutation for the Banners entity.
func newBannersMutation(c config, op Op, opts ...bannersOption) *BannersMutation {
	m := &BannersMutation{
		config:        c,
		op:            op,
		typ:           TypeBanners,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannersID sets the ID field of the mutation.
func withBannersID(id int) bannersOption {
	return func(m *BannersMutation) {
		var (
			err   error
			once  sync.Once
			value *Banners
		)
		m.oldValue = func(ctx context.Context) (*Banners, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Banners.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanners sets the old Banners of the mutation.
func withBanners(node *Banners) bannersOption {
	return func(m *BannersMutation) {
		m.oldValue = func(context.Context) (*Banners, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannersMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Banners.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *BannersMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BannersMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Banners entity.
// If the Banners object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannersMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *BannersMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[banners.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *BannersMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[banners.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BannersMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, banners.FieldUserID)
}

// SetTitle sets the "title" field.
func (m *BannersMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BannersMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Banners entity.
// If the Banners object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannersMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BannersMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BannersMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BannersMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Banners entity.
// If the Banners object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannersMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BannersMutation) ResetDescription() {
	m.description = nil
}

// SetImage sets the "image" field.
func (m *BannersMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *BannersMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Banners entity.
// If the Banners object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannersMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *BannersMutation) ResetImage() {
	m.image = nil
}

// SetUsersID sets the "users" edge to the Users entity by id.
func (m *BannersMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *BannersMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[banners.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *BannersMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *BannersMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *BannersMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *BannersMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the BannersMutation builder.
func (m *BannersMutation) Where(ps ...predicate.Banners) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Banners, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Banners).
func (m *BannersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannersMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.users != nil {
		fields = append(fields, banners.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, banners.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, banners.FieldDescription)
	}
	if m.image != nil {
		fields = append(fields, banners.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banners.FieldUserID:
		return m.UserID()
	case banners.FieldTitle:
		return m.Title()
	case banners.FieldDescription:
		return m.Description()
	case banners.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banners.FieldUserID:
		return m.OldUserID(ctx)
	case banners.FieldTitle:
		return m.OldTitle(ctx)
	case banners.FieldDescription:
		return m.OldDescription(ctx)
	case banners.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown Banners field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banners.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case banners.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case banners.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case banners.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown Banners field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannersMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannersMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Banners numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(banners.FieldUserID) {
		fields = append(fields, banners.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannersMutation) ClearField(name string) error {
	switch name {
	case banners.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Banners nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannersMutation) ResetField(name string) error {
	switch name {
	case banners.FieldUserID:
		m.ResetUserID()
		return nil
	case banners.FieldTitle:
		m.ResetTitle()
		return nil
	case banners.FieldDescription:
		m.ResetDescription()
		return nil
	case banners.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown Banners field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannersMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, banners.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case banners.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, banners.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannersMutation) EdgeCleared(name string) bool {
	switch name {
	case banners.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannersMutation) ClearEdge(name string) error {
	switch name {
	case banners.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown Banners unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannersMutation) ResetEdge(name string) error {
	switch name {
	case banners.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Banners edge %s", name)
}

// DebitCardDesignMutation represents an operation that mutates the DebitCardDesign nodes in the graph.
type DebitCardDesignMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	color              *string
	border_color       *string
	clearedFields      map[string]struct{}
	users              *int
	clearedusers       bool
	debit_cards        *int
	cleareddebit_cards bool
	done               bool
	oldValue           func(context.Context) (*DebitCardDesign, error)
	predicates         []predicate.DebitCardDesign
}

var _ ent.Mutation = (*DebitCardDesignMutation)(nil)

// debitcarddesignOption allows management of the mutation configuration using functional options.
type debitcarddesignOption func(*DebitCardDesignMutation)

// newDebitCardDesignMutation creates new mutation for the DebitCardDesign entity.
func newDebitCardDesignMutation(c config, op Op, opts ...debitcarddesignOption) *DebitCardDesignMutation {
	m := &DebitCardDesignMutation{
		config:        c,
		op:            op,
		typ:           TypeDebitCardDesign,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDebitCardDesignID sets the ID field of the mutation.
func withDebitCardDesignID(id int) debitcarddesignOption {
	return func(m *DebitCardDesignMutation) {
		var (
			err   error
			once  sync.Once
			value *DebitCardDesign
		)
		m.oldValue = func(ctx context.Context) (*DebitCardDesign, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DebitCardDesign.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDebitCardDesign sets the old DebitCardDesign of the mutation.
func withDebitCardDesign(node *DebitCardDesign) debitcarddesignOption {
	return func(m *DebitCardDesignMutation) {
		m.oldValue = func(context.Context) (*DebitCardDesign, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DebitCardDesignMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DebitCardDesignMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DebitCardDesignMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DebitCardDesignMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DebitCardDesign.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCardID sets the "card_id" field.
func (m *DebitCardDesignMutation) SetCardID(i int) {
	m.debit_cards = &i
}

// CardID returns the value of the "card_id" field in the mutation.
func (m *DebitCardDesignMutation) CardID() (r int, exists bool) {
	v := m.debit_cards
	if v == nil {
		return
	}
	return *v, true
}

// OldCardID returns the old "card_id" field's value of the DebitCardDesign entity.
// If the DebitCardDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardDesignMutation) OldCardID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardID: %w", err)
	}
	return oldValue.CardID, nil
}

// ClearCardID clears the value of the "card_id" field.
func (m *DebitCardDesignMutation) ClearCardID() {
	m.debit_cards = nil
	m.clearedFields[debitcarddesign.FieldCardID] = struct{}{}
}

// CardIDCleared returns if the "card_id" field was cleared in this mutation.
func (m *DebitCardDesignMutation) CardIDCleared() bool {
	_, ok := m.clearedFields[debitcarddesign.FieldCardID]
	return ok
}

// ResetCardID resets all changes to the "card_id" field.
func (m *DebitCardDesignMutation) ResetCardID() {
	m.debit_cards = nil
	delete(m.clearedFields, debitcarddesign.FieldCardID)
}

// SetUserID sets the "user_id" field.
func (m *DebitCardDesignMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DebitCardDesignMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DebitCardDesign entity.
// If the DebitCardDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardDesignMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *DebitCardDesignMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[debitcarddesign.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *DebitCardDesignMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[debitcarddesign.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DebitCardDesignMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, debitcarddesign.FieldUserID)
}

// SetColor sets the "color" field.
func (m *DebitCardDesignMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *DebitCardDesignMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the DebitCardDesign entity.
// If the DebitCardDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardDesignMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *DebitCardDesignMutation) ResetColor() {
	m.color = nil
}

// SetBorderColor sets the "border_color" field.
func (m *DebitCardDesignMutation) SetBorderColor(s string) {
	m.border_color = &s
}

// BorderColor returns the value of the "border_color" field in the mutation.
func (m *DebitCardDesignMutation) BorderColor() (r string, exists bool) {
	v := m.border_color
	if v == nil {
		return
	}
	return *v, true
}

// OldBorderColor returns the old "border_color" field's value of the DebitCardDesign entity.
// If the DebitCardDesign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardDesignMutation) OldBorderColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBorderColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBorderColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBorderColor: %w", err)
	}
	return oldValue.BorderColor, nil
}

// ResetBorderColor resets all changes to the "border_color" field.
func (m *DebitCardDesignMutation) ResetBorderColor() {
	m.border_color = nil
}

// SetUsersID sets the "users" edge to the Users entity by id.
func (m *DebitCardDesignMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *DebitCardDesignMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[debitcarddesign.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *DebitCardDesignMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *DebitCardDesignMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *DebitCardDesignMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DebitCardDesignMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// SetDebitCardsID sets the "debit_cards" edge to the DebitCards entity by id.
func (m *DebitCardDesignMutation) SetDebitCardsID(id int) {
	m.debit_cards = &id
}

// ClearDebitCards clears the "debit_cards" edge to the DebitCards entity.
func (m *DebitCardDesignMutation) ClearDebitCards() {
	m.cleareddebit_cards = true
	m.clearedFields[debitcarddesign.FieldCardID] = struct{}{}
}

// DebitCardsCleared reports if the "debit_cards" edge to the DebitCards entity was cleared.
func (m *DebitCardDesignMutation) DebitCardsCleared() bool {
	return m.CardIDCleared() || m.cleareddebit_cards
}

// DebitCardsID returns the "debit_cards" edge ID in the mutation.
func (m *DebitCardDesignMutation) DebitCardsID() (id int, exists bool) {
	if m.debit_cards != nil {
		return *m.debit_cards, true
	}
	return
}

// DebitCardsIDs returns the "debit_cards" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DebitCardsID instead. It exists only for internal usage by the builders.
func (m *DebitCardDesignMutation) DebitCardsIDs() (ids []int) {
	if id := m.debit_cards; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDebitCards resets all changes to the "debit_cards" edge.
func (m *DebitCardDesignMutation) ResetDebitCards() {
	m.debit_cards = nil
	m.cleareddebit_cards = false
}

// Where appends a list predicates to the DebitCardDesignMutation builder.
func (m *DebitCardDesignMutation) Where(ps ...predicate.DebitCardDesign) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DebitCardDesignMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DebitCardDesignMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DebitCardDesign, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DebitCardDesignMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DebitCardDesignMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DebitCardDesign).
func (m *DebitCardDesignMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DebitCardDesignMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.debit_cards != nil {
		fields = append(fields, debitcarddesign.FieldCardID)
	}
	if m.users != nil {
		fields = append(fields, debitcarddesign.FieldUserID)
	}
	if m.color != nil {
		fields = append(fields, debitcarddesign.FieldColor)
	}
	if m.border_color != nil {
		fields = append(fields, debitcarddesign.FieldBorderColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DebitCardDesignMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case debitcarddesign.FieldCardID:
		return m.CardID()
	case debitcarddesign.FieldUserID:
		return m.UserID()
	case debitcarddesign.FieldColor:
		return m.Color()
	case debitcarddesign.FieldBorderColor:
		return m.BorderColor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DebitCardDesignMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case debitcarddesign.FieldCardID:
		return m.OldCardID(ctx)
	case debitcarddesign.FieldUserID:
		return m.OldUserID(ctx)
	case debitcarddesign.FieldColor:
		return m.OldColor(ctx)
	case debitcarddesign.FieldBorderColor:
		return m.OldBorderColor(ctx)
	}
	return nil, fmt.Errorf("unknown DebitCardDesign field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DebitCardDesignMutation) SetField(name string, value ent.Value) error {
	switch name {
	case debitcarddesign.FieldCardID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardID(v)
		return nil
	case debitcarddesign.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case debitcarddesign.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case debitcarddesign.FieldBorderColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBorderColor(v)
		return nil
	}
	return fmt.Errorf("unknown DebitCardDesign field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DebitCardDesignMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DebitCardDesignMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DebitCardDesignMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DebitCardDesign numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DebitCardDesignMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(debitcarddesign.FieldCardID) {
		fields = append(fields, debitcarddesign.FieldCardID)
	}
	if m.FieldCleared(debitcarddesign.FieldUserID) {
		fields = append(fields, debitcarddesign.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DebitCardDesignMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DebitCardDesignMutation) ClearField(name string) error {
	switch name {
	case debitcarddesign.FieldCardID:
		m.ClearCardID()
		return nil
	case debitcarddesign.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown DebitCardDesign nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DebitCardDesignMutation) ResetField(name string) error {
	switch name {
	case debitcarddesign.FieldCardID:
		m.ResetCardID()
		return nil
	case debitcarddesign.FieldUserID:
		m.ResetUserID()
		return nil
	case debitcarddesign.FieldColor:
		m.ResetColor()
		return nil
	case debitcarddesign.FieldBorderColor:
		m.ResetBorderColor()
		return nil
	}
	return fmt.Errorf("unknown DebitCardDesign field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DebitCardDesignMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, debitcarddesign.EdgeUsers)
	}
	if m.debit_cards != nil {
		edges = append(edges, debitcarddesign.EdgeDebitCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DebitCardDesignMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case debitcarddesign.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case debitcarddesign.EdgeDebitCards:
		if id := m.debit_cards; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DebitCardDesignMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DebitCardDesignMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DebitCardDesignMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, debitcarddesign.EdgeUsers)
	}
	if m.cleareddebit_cards {
		edges = append(edges, debitcarddesign.EdgeDebitCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DebitCardDesignMutation) EdgeCleared(name string) bool {
	switch name {
	case debitcarddesign.EdgeUsers:
		return m.clearedusers
	case debitcarddesign.EdgeDebitCards:
		return m.cleareddebit_cards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DebitCardDesignMutation) ClearEdge(name string) error {
	switch name {
	case debitcarddesign.EdgeUsers:
		m.ClearUsers()
		return nil
	case debitcarddesign.EdgeDebitCards:
		m.ClearDebitCards()
		return nil
	}
	return fmt.Errorf("unknown DebitCardDesign unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DebitCardDesignMutation) ResetEdge(name string) error {
	switch name {
	case debitcarddesign.EdgeUsers:
		m.ResetUsers()
		return nil
	case debitcarddesign.EdgeDebitCards:
		m.ResetDebitCards()
		return nil
	}
	return fmt.Errorf("unknown DebitCardDesign edge %s", name)
}

// DebitCardDetailsMutation represents an operation that mutates the DebitCardDetails nodes in the graph.
type DebitCardDetailsMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	issuer             *string
	number             *string
	clearedFields      map[string]struct{}
	users              *int
	clearedusers       bool
	debit_cards        *int
	cleareddebit_cards bool
	done               bool
	oldValue           func(context.Context) (*DebitCardDetails, error)
	predicates         []predicate.DebitCardDetails
}

var _ ent.Mutation = (*DebitCardDetailsMutation)(nil)

// debitcarddetailsOption allows management of the mutation configuration using functional options.
type debitcarddetailsOption func(*DebitCardDetailsMutation)

// newDebitCardDetailsMutation creates new mutation for the DebitCardDetails entity.
func newDebitCardDetailsMutation(c config, op Op, opts ...debitcarddetailsOption) *DebitCardDetailsMutation {
	m := &DebitCardDetailsMutation{
		config:        c,
		op:            op,
		typ:           TypeDebitCardDetails,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDebitCardDetailsID sets the ID field of the mutation.
func withDebitCardDetailsID(id int) debitcarddetailsOption {
	return func(m *DebitCardDetailsMutation) {
		var (
			err   error
			once  sync.Once
			value *DebitCardDetails
		)
		m.oldValue = func(ctx context.Context) (*DebitCardDetails, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DebitCardDetails.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDebitCardDetails sets the old DebitCardDetails of the mutation.
func withDebitCardDetails(node *DebitCardDetails) debitcarddetailsOption {
	return func(m *DebitCardDetailsMutation) {
		m.oldValue = func(context.Context) (*DebitCardDetails, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DebitCardDetailsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DebitCardDetailsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DebitCardDetailsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DebitCardDetailsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DebitCardDetails.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCardID sets the "card_id" field.
func (m *DebitCardDetailsMutation) SetCardID(i int) {
	m.debit_cards = &i
}

// CardID returns the value of the "card_id" field in the mutation.
func (m *DebitCardDetailsMutation) CardID() (r int, exists bool) {
	v := m.debit_cards
	if v == nil {
		return
	}
	return *v, true
}

// OldCardID returns the old "card_id" field's value of the DebitCardDetails entity.
// If the DebitCardDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardDetailsMutation) OldCardID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardID: %w", err)
	}
	return oldValue.CardID, nil
}

// ClearCardID clears the value of the "card_id" field.
func (m *DebitCardDetailsMutation) ClearCardID() {
	m.debit_cards = nil
	m.clearedFields[debitcarddetails.FieldCardID] = struct{}{}
}

// CardIDCleared returns if the "card_id" field was cleared in this mutation.
func (m *DebitCardDetailsMutation) CardIDCleared() bool {
	_, ok := m.clearedFields[debitcarddetails.FieldCardID]
	return ok
}

// ResetCardID resets all changes to the "card_id" field.
func (m *DebitCardDetailsMutation) ResetCardID() {
	m.debit_cards = nil
	delete(m.clearedFields, debitcarddetails.FieldCardID)
}

// SetUserID sets the "user_id" field.
func (m *DebitCardDetailsMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DebitCardDetailsMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DebitCardDetails entity.
// If the DebitCardDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardDetailsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *DebitCardDetailsMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[debitcarddetails.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *DebitCardDetailsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[debitcarddetails.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DebitCardDetailsMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, debitcarddetails.FieldUserID)
}

// SetIssuer sets the "issuer" field.
func (m *DebitCardDetailsMutation) SetIssuer(s string) {
	m.issuer = &s
}

// Issuer returns the value of the "issuer" field in the mutation.
func (m *DebitCardDetailsMutation) Issuer() (r string, exists bool) {
	v := m.issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuer returns the old "issuer" field's value of the DebitCardDetails entity.
// If the DebitCardDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardDetailsMutation) OldIssuer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuer: %w", err)
	}
	return oldValue.Issuer, nil
}

// ResetIssuer resets all changes to the "issuer" field.
func (m *DebitCardDetailsMutation) ResetIssuer() {
	m.issuer = nil
}

// SetNumber sets the "number" field.
func (m *DebitCardDetailsMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *DebitCardDetailsMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the DebitCardDetails entity.
// If the DebitCardDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardDetailsMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "number" field.
func (m *DebitCardDetailsMutation) ResetNumber() {
	m.number = nil
}

// SetUsersID sets the "users" edge to the Users entity by id.
func (m *DebitCardDetailsMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *DebitCardDetailsMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[debitcarddetails.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *DebitCardDetailsMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *DebitCardDetailsMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *DebitCardDetailsMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DebitCardDetailsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// SetDebitCardsID sets the "debit_cards" edge to the DebitCards entity by id.
func (m *DebitCardDetailsMutation) SetDebitCardsID(id int) {
	m.debit_cards = &id
}

// ClearDebitCards clears the "debit_cards" edge to the DebitCards entity.
func (m *DebitCardDetailsMutation) ClearDebitCards() {
	m.cleareddebit_cards = true
	m.clearedFields[debitcarddetails.FieldCardID] = struct{}{}
}

// DebitCardsCleared reports if the "debit_cards" edge to the DebitCards entity was cleared.
func (m *DebitCardDetailsMutation) DebitCardsCleared() bool {
	return m.CardIDCleared() || m.cleareddebit_cards
}

// DebitCardsID returns the "debit_cards" edge ID in the mutation.
func (m *DebitCardDetailsMutation) DebitCardsID() (id int, exists bool) {
	if m.debit_cards != nil {
		return *m.debit_cards, true
	}
	return
}

// DebitCardsIDs returns the "debit_cards" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DebitCardsID instead. It exists only for internal usage by the builders.
func (m *DebitCardDetailsMutation) DebitCardsIDs() (ids []int) {
	if id := m.debit_cards; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDebitCards resets all changes to the "debit_cards" edge.
func (m *DebitCardDetailsMutation) ResetDebitCards() {
	m.debit_cards = nil
	m.cleareddebit_cards = false
}

// Where appends a list predicates to the DebitCardDetailsMutation builder.
func (m *DebitCardDetailsMutation) Where(ps ...predicate.DebitCardDetails) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DebitCardDetailsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DebitCardDetailsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DebitCardDetails, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DebitCardDetailsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DebitCardDetailsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DebitCardDetails).
func (m *DebitCardDetailsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DebitCardDetailsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.debit_cards != nil {
		fields = append(fields, debitcarddetails.FieldCardID)
	}
	if m.users != nil {
		fields = append(fields, debitcarddetails.FieldUserID)
	}
	if m.issuer != nil {
		fields = append(fields, debitcarddetails.FieldIssuer)
	}
	if m.number != nil {
		fields = append(fields, debitcarddetails.FieldNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DebitCardDetailsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case debitcarddetails.FieldCardID:
		return m.CardID()
	case debitcarddetails.FieldUserID:
		return m.UserID()
	case debitcarddetails.FieldIssuer:
		return m.Issuer()
	case debitcarddetails.FieldNumber:
		return m.Number()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DebitCardDetailsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case debitcarddetails.FieldCardID:
		return m.OldCardID(ctx)
	case debitcarddetails.FieldUserID:
		return m.OldUserID(ctx)
	case debitcarddetails.FieldIssuer:
		return m.OldIssuer(ctx)
	case debitcarddetails.FieldNumber:
		return m.OldNumber(ctx)
	}
	return nil, fmt.Errorf("unknown DebitCardDetails field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DebitCardDetailsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case debitcarddetails.FieldCardID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardID(v)
		return nil
	case debitcarddetails.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case debitcarddetails.FieldIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuer(v)
		return nil
	case debitcarddetails.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	}
	return fmt.Errorf("unknown DebitCardDetails field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DebitCardDetailsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DebitCardDetailsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DebitCardDetailsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DebitCardDetails numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DebitCardDetailsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(debitcarddetails.FieldCardID) {
		fields = append(fields, debitcarddetails.FieldCardID)
	}
	if m.FieldCleared(debitcarddetails.FieldUserID) {
		fields = append(fields, debitcarddetails.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DebitCardDetailsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DebitCardDetailsMutation) ClearField(name string) error {
	switch name {
	case debitcarddetails.FieldCardID:
		m.ClearCardID()
		return nil
	case debitcarddetails.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown DebitCardDetails nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DebitCardDetailsMutation) ResetField(name string) error {
	switch name {
	case debitcarddetails.FieldCardID:
		m.ResetCardID()
		return nil
	case debitcarddetails.FieldUserID:
		m.ResetUserID()
		return nil
	case debitcarddetails.FieldIssuer:
		m.ResetIssuer()
		return nil
	case debitcarddetails.FieldNumber:
		m.ResetNumber()
		return nil
	}
	return fmt.Errorf("unknown DebitCardDetails field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DebitCardDetailsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, debitcarddetails.EdgeUsers)
	}
	if m.debit_cards != nil {
		edges = append(edges, debitcarddetails.EdgeDebitCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DebitCardDetailsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case debitcarddetails.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case debitcarddetails.EdgeDebitCards:
		if id := m.debit_cards; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DebitCardDetailsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DebitCardDetailsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DebitCardDetailsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, debitcarddetails.EdgeUsers)
	}
	if m.cleareddebit_cards {
		edges = append(edges, debitcarddetails.EdgeDebitCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DebitCardDetailsMutation) EdgeCleared(name string) bool {
	switch name {
	case debitcarddetails.EdgeUsers:
		return m.clearedusers
	case debitcarddetails.EdgeDebitCards:
		return m.cleareddebit_cards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DebitCardDetailsMutation) ClearEdge(name string) error {
	switch name {
	case debitcarddetails.EdgeUsers:
		m.ClearUsers()
		return nil
	case debitcarddetails.EdgeDebitCards:
		m.ClearDebitCards()
		return nil
	}
	return fmt.Errorf("unknown DebitCardDetails unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DebitCardDetailsMutation) ResetEdge(name string) error {
	switch name {
	case debitcarddetails.EdgeUsers:
		m.ResetUsers()
		return nil
	case debitcarddetails.EdgeDebitCards:
		m.ResetDebitCards()
		return nil
	}
	return fmt.Errorf("unknown DebitCardDetails edge %s", name)
}

// DebitCardStatusMutation represents an operation that mutates the DebitCardStatus nodes in the graph.
type DebitCardStatusMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	status             *string
	clearedFields      map[string]struct{}
	users              *int
	clearedusers       bool
	debit_cards        *int
	cleareddebit_cards bool
	done               bool
	oldValue           func(context.Context) (*DebitCardStatus, error)
	predicates         []predicate.DebitCardStatus
}

var _ ent.Mutation = (*DebitCardStatusMutation)(nil)

// debitcardstatusOption allows management of the mutation configuration using functional options.
type debitcardstatusOption func(*DebitCardStatusMutation)

// newDebitCardStatusMutation creates new mutation for the DebitCardStatus entity.
func newDebitCardStatusMutation(c config, op Op, opts ...debitcardstatusOption) *DebitCardStatusMutation {
	m := &DebitCardStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeDebitCardStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDebitCardStatusID sets the ID field of the mutation.
func withDebitCardStatusID(id int) debitcardstatusOption {
	return func(m *DebitCardStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *DebitCardStatus
		)
		m.oldValue = func(ctx context.Context) (*DebitCardStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DebitCardStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDebitCardStatus sets the old DebitCardStatus of the mutation.
func withDebitCardStatus(node *DebitCardStatus) debitcardstatusOption {
	return func(m *DebitCardStatusMutation) {
		m.oldValue = func(context.Context) (*DebitCardStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DebitCardStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DebitCardStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DebitCardStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DebitCardStatusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DebitCardStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCardID sets the "card_id" field.
func (m *DebitCardStatusMutation) SetCardID(i int) {
	m.debit_cards = &i
}

// CardID returns the value of the "card_id" field in the mutation.
func (m *DebitCardStatusMutation) CardID() (r int, exists bool) {
	v := m.debit_cards
	if v == nil {
		return
	}
	return *v, true
}

// OldCardID returns the old "card_id" field's value of the DebitCardStatus entity.
// If the DebitCardStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardStatusMutation) OldCardID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardID: %w", err)
	}
	return oldValue.CardID, nil
}

// ClearCardID clears the value of the "card_id" field.
func (m *DebitCardStatusMutation) ClearCardID() {
	m.debit_cards = nil
	m.clearedFields[debitcardstatus.FieldCardID] = struct{}{}
}

// CardIDCleared returns if the "card_id" field was cleared in this mutation.
func (m *DebitCardStatusMutation) CardIDCleared() bool {
	_, ok := m.clearedFields[debitcardstatus.FieldCardID]
	return ok
}

// ResetCardID resets all changes to the "card_id" field.
func (m *DebitCardStatusMutation) ResetCardID() {
	m.debit_cards = nil
	delete(m.clearedFields, debitcardstatus.FieldCardID)
}

// SetUserID sets the "user_id" field.
func (m *DebitCardStatusMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DebitCardStatusMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DebitCardStatus entity.
// If the DebitCardStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardStatusMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *DebitCardStatusMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[debitcardstatus.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *DebitCardStatusMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[debitcardstatus.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DebitCardStatusMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, debitcardstatus.FieldUserID)
}

// SetStatus sets the "status" field.
func (m *DebitCardStatusMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *DebitCardStatusMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DebitCardStatus entity.
// If the DebitCardStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardStatusMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DebitCardStatusMutation) ResetStatus() {
	m.status = nil
}

// SetUsersID sets the "users" edge to the Users entity by id.
func (m *DebitCardStatusMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *DebitCardStatusMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[debitcardstatus.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *DebitCardStatusMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *DebitCardStatusMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *DebitCardStatusMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DebitCardStatusMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// SetDebitCardsID sets the "debit_cards" edge to the DebitCards entity by id.
func (m *DebitCardStatusMutation) SetDebitCardsID(id int) {
	m.debit_cards = &id
}

// ClearDebitCards clears the "debit_cards" edge to the DebitCards entity.
func (m *DebitCardStatusMutation) ClearDebitCards() {
	m.cleareddebit_cards = true
	m.clearedFields[debitcardstatus.FieldCardID] = struct{}{}
}

// DebitCardsCleared reports if the "debit_cards" edge to the DebitCards entity was cleared.
func (m *DebitCardStatusMutation) DebitCardsCleared() bool {
	return m.CardIDCleared() || m.cleareddebit_cards
}

// DebitCardsID returns the "debit_cards" edge ID in the mutation.
func (m *DebitCardStatusMutation) DebitCardsID() (id int, exists bool) {
	if m.debit_cards != nil {
		return *m.debit_cards, true
	}
	return
}

// DebitCardsIDs returns the "debit_cards" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DebitCardsID instead. It exists only for internal usage by the builders.
func (m *DebitCardStatusMutation) DebitCardsIDs() (ids []int) {
	if id := m.debit_cards; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDebitCards resets all changes to the "debit_cards" edge.
func (m *DebitCardStatusMutation) ResetDebitCards() {
	m.debit_cards = nil
	m.cleareddebit_cards = false
}

// Where appends a list predicates to the DebitCardStatusMutation builder.
func (m *DebitCardStatusMutation) Where(ps ...predicate.DebitCardStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DebitCardStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DebitCardStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DebitCardStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DebitCardStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DebitCardStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DebitCardStatus).
func (m *DebitCardStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DebitCardStatusMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.debit_cards != nil {
		fields = append(fields, debitcardstatus.FieldCardID)
	}
	if m.users != nil {
		fields = append(fields, debitcardstatus.FieldUserID)
	}
	if m.status != nil {
		fields = append(fields, debitcardstatus.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DebitCardStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case debitcardstatus.FieldCardID:
		return m.CardID()
	case debitcardstatus.FieldUserID:
		return m.UserID()
	case debitcardstatus.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DebitCardStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case debitcardstatus.FieldCardID:
		return m.OldCardID(ctx)
	case debitcardstatus.FieldUserID:
		return m.OldUserID(ctx)
	case debitcardstatus.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown DebitCardStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DebitCardStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case debitcardstatus.FieldCardID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardID(v)
		return nil
	case debitcardstatus.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case debitcardstatus.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown DebitCardStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DebitCardStatusMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DebitCardStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DebitCardStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DebitCardStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DebitCardStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(debitcardstatus.FieldCardID) {
		fields = append(fields, debitcardstatus.FieldCardID)
	}
	if m.FieldCleared(debitcardstatus.FieldUserID) {
		fields = append(fields, debitcardstatus.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DebitCardStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DebitCardStatusMutation) ClearField(name string) error {
	switch name {
	case debitcardstatus.FieldCardID:
		m.ClearCardID()
		return nil
	case debitcardstatus.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown DebitCardStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DebitCardStatusMutation) ResetField(name string) error {
	switch name {
	case debitcardstatus.FieldCardID:
		m.ResetCardID()
		return nil
	case debitcardstatus.FieldUserID:
		m.ResetUserID()
		return nil
	case debitcardstatus.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown DebitCardStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DebitCardStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, debitcardstatus.EdgeUsers)
	}
	if m.debit_cards != nil {
		edges = append(edges, debitcardstatus.EdgeDebitCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DebitCardStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case debitcardstatus.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case debitcardstatus.EdgeDebitCards:
		if id := m.debit_cards; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DebitCardStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DebitCardStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DebitCardStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, debitcardstatus.EdgeUsers)
	}
	if m.cleareddebit_cards {
		edges = append(edges, debitcardstatus.EdgeDebitCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DebitCardStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case debitcardstatus.EdgeUsers:
		return m.clearedusers
	case debitcardstatus.EdgeDebitCards:
		return m.cleareddebit_cards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DebitCardStatusMutation) ClearEdge(name string) error {
	switch name {
	case debitcardstatus.EdgeUsers:
		m.ClearUsers()
		return nil
	case debitcardstatus.EdgeDebitCards:
		m.ClearDebitCards()
		return nil
	}
	return fmt.Errorf("unknown DebitCardStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DebitCardStatusMutation) ResetEdge(name string) error {
	switch name {
	case debitcardstatus.EdgeUsers:
		m.ResetUsers()
		return nil
	case debitcardstatus.EdgeDebitCards:
		m.ResetDebitCards()
		return nil
	}
	return fmt.Errorf("unknown DebitCardStatus edge %s", name)
}

// DebitCardsMutation represents an operation that mutates the DebitCards nodes in the graph.
type DebitCardsMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	clearedFields             map[string]struct{}
	debit_card_design         map[int]struct{}
	removeddebit_card_design  map[int]struct{}
	cleareddebit_card_design  bool
	debit_card_details        map[int]struct{}
	removeddebit_card_details map[int]struct{}
	cleareddebit_card_details bool
	debit_card_status         map[int]struct{}
	removeddebit_card_status  map[int]struct{}
	cleareddebit_card_status  bool
	users                     *int
	clearedusers              bool
	done                      bool
	oldValue                  func(context.Context) (*DebitCards, error)
	predicates                []predicate.DebitCards
}

var _ ent.Mutation = (*DebitCardsMutation)(nil)

// debitcardsOption allows management of the mutation configuration using functional options.
type debitcardsOption func(*DebitCardsMutation)

// newDebitCardsMutation creates new mutation for the DebitCards entity.
func newDebitCardsMutation(c config, op Op, opts ...debitcardsOption) *DebitCardsMutation {
	m := &DebitCardsMutation{
		config:        c,
		op:            op,
		typ:           TypeDebitCards,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDebitCardsID sets the ID field of the mutation.
func withDebitCardsID(id int) debitcardsOption {
	return func(m *DebitCardsMutation) {
		var (
			err   error
			once  sync.Once
			value *DebitCards
		)
		m.oldValue = func(ctx context.Context) (*DebitCards, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DebitCards.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDebitCards sets the old DebitCards of the mutation.
func withDebitCards(node *DebitCards) debitcardsOption {
	return func(m *DebitCardsMutation) {
		m.oldValue = func(context.Context) (*DebitCards, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DebitCardsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DebitCardsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DebitCardsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DebitCardsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DebitCards.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *DebitCardsMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DebitCardsMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DebitCards entity.
// If the DebitCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *DebitCardsMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[debitcards.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *DebitCardsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[debitcards.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DebitCardsMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, debitcards.FieldUserID)
}

// SetName sets the "name" field.
func (m *DebitCardsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DebitCardsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DebitCards entity.
// If the DebitCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DebitCardsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DebitCardsMutation) ResetName() {
	m.name = nil
}

// AddDebitCardDesignIDs adds the "debit_card_design" edge to the DebitCardDesign entity by ids.
func (m *DebitCardsMutation) AddDebitCardDesignIDs(ids ...int) {
	if m.debit_card_design == nil {
		m.debit_card_design = make(map[int]struct{})
	}
	for i := range ids {
		m.debit_card_design[ids[i]] = struct{}{}
	}
}

// ClearDebitCardDesign clears the "debit_card_design" edge to the DebitCardDesign entity.
func (m *DebitCardsMutation) ClearDebitCardDesign() {
	m.cleareddebit_card_design = true
}

// DebitCardDesignCleared reports if the "debit_card_design" edge to the DebitCardDesign entity was cleared.
func (m *DebitCardsMutation) DebitCardDesignCleared() bool {
	return m.cleareddebit_card_design
}

// RemoveDebitCardDesignIDs removes the "debit_card_design" edge to the DebitCardDesign entity by IDs.
func (m *DebitCardsMutation) RemoveDebitCardDesignIDs(ids ...int) {
	if m.removeddebit_card_design == nil {
		m.removeddebit_card_design = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.debit_card_design, ids[i])
		m.removeddebit_card_design[ids[i]] = struct{}{}
	}
}

// RemovedDebitCardDesign returns the removed IDs of the "debit_card_design" edge to the DebitCardDesign entity.
func (m *DebitCardsMutation) RemovedDebitCardDesignIDs() (ids []int) {
	for id := range m.removeddebit_card_design {
		ids = append(ids, id)
	}
	return
}

// DebitCardDesignIDs returns the "debit_card_design" edge IDs in the mutation.
func (m *DebitCardsMutation) DebitCardDesignIDs() (ids []int) {
	for id := range m.debit_card_design {
		ids = append(ids, id)
	}
	return
}

// ResetDebitCardDesign resets all changes to the "debit_card_design" edge.
func (m *DebitCardsMutation) ResetDebitCardDesign() {
	m.debit_card_design = nil
	m.cleareddebit_card_design = false
	m.removeddebit_card_design = nil
}

// AddDebitCardDetailIDs adds the "debit_card_details" edge to the DebitCardDetails entity by ids.
func (m *DebitCardsMutation) AddDebitCardDetailIDs(ids ...int) {
	if m.debit_card_details == nil {
		m.debit_card_details = make(map[int]struct{})
	}
	for i := range ids {
		m.debit_card_details[ids[i]] = struct{}{}
	}
}

// ClearDebitCardDetails clears the "debit_card_details" edge to the DebitCardDetails entity.
func (m *DebitCardsMutation) ClearDebitCardDetails() {
	m.cleareddebit_card_details = true
}

// DebitCardDetailsCleared reports if the "debit_card_details" edge to the DebitCardDetails entity was cleared.
func (m *DebitCardsMutation) DebitCardDetailsCleared() bool {
	return m.cleareddebit_card_details
}

// RemoveDebitCardDetailIDs removes the "debit_card_details" edge to the DebitCardDetails entity by IDs.
func (m *DebitCardsMutation) RemoveDebitCardDetailIDs(ids ...int) {
	if m.removeddebit_card_details == nil {
		m.removeddebit_card_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.debit_card_details, ids[i])
		m.removeddebit_card_details[ids[i]] = struct{}{}
	}
}

// RemovedDebitCardDetails returns the removed IDs of the "debit_card_details" edge to the DebitCardDetails entity.
func (m *DebitCardsMutation) RemovedDebitCardDetailsIDs() (ids []int) {
	for id := range m.removeddebit_card_details {
		ids = append(ids, id)
	}
	return
}

// DebitCardDetailsIDs returns the "debit_card_details" edge IDs in the mutation.
func (m *DebitCardsMutation) DebitCardDetailsIDs() (ids []int) {
	for id := range m.debit_card_details {
		ids = append(ids, id)
	}
	return
}

// ResetDebitCardDetails resets all changes to the "debit_card_details" edge.
func (m *DebitCardsMutation) ResetDebitCardDetails() {
	m.debit_card_details = nil
	m.cleareddebit_card_details = false
	m.removeddebit_card_details = nil
}

// AddDebitCardStatuIDs adds the "debit_card_status" edge to the DebitCardStatus entity by ids.
func (m *DebitCardsMutation) AddDebitCardStatuIDs(ids ...int) {
	if m.debit_card_status == nil {
		m.debit_card_status = make(map[int]struct{})
	}
	for i := range ids {
		m.debit_card_status[ids[i]] = struct{}{}
	}
}

// ClearDebitCardStatus clears the "debit_card_status" edge to the DebitCardStatus entity.
func (m *DebitCardsMutation) ClearDebitCardStatus() {
	m.cleareddebit_card_status = true
}

// DebitCardStatusCleared reports if the "debit_card_status" edge to the DebitCardStatus entity was cleared.
func (m *DebitCardsMutation) DebitCardStatusCleared() bool {
	return m.cleareddebit_card_status
}

// RemoveDebitCardStatuIDs removes the "debit_card_status" edge to the DebitCardStatus entity by IDs.
func (m *DebitCardsMutation) RemoveDebitCardStatuIDs(ids ...int) {
	if m.removeddebit_card_status == nil {
		m.removeddebit_card_status = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.debit_card_status, ids[i])
		m.removeddebit_card_status[ids[i]] = struct{}{}
	}
}

// RemovedDebitCardStatus returns the removed IDs of the "debit_card_status" edge to the DebitCardStatus entity.
func (m *DebitCardsMutation) RemovedDebitCardStatusIDs() (ids []int) {
	for id := range m.removeddebit_card_status {
		ids = append(ids, id)
	}
	return
}

// DebitCardStatusIDs returns the "debit_card_status" edge IDs in the mutation.
func (m *DebitCardsMutation) DebitCardStatusIDs() (ids []int) {
	for id := range m.debit_card_status {
		ids = append(ids, id)
	}
	return
}

// ResetDebitCardStatus resets all changes to the "debit_card_status" edge.
func (m *DebitCardsMutation) ResetDebitCardStatus() {
	m.debit_card_status = nil
	m.cleareddebit_card_status = false
	m.removeddebit_card_status = nil
}

// SetUsersID sets the "users" edge to the Users entity by id.
func (m *DebitCardsMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *DebitCardsMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[debitcards.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *DebitCardsMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *DebitCardsMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *DebitCardsMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DebitCardsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the DebitCardsMutation builder.
func (m *DebitCardsMutation) Where(ps ...predicate.DebitCards) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DebitCardsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DebitCardsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DebitCards, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DebitCardsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DebitCardsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DebitCards).
func (m *DebitCardsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DebitCardsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.users != nil {
		fields = append(fields, debitcards.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, debitcards.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DebitCardsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case debitcards.FieldUserID:
		return m.UserID()
	case debitcards.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DebitCardsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case debitcards.FieldUserID:
		return m.OldUserID(ctx)
	case debitcards.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown DebitCards field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DebitCardsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case debitcards.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case debitcards.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown DebitCards field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DebitCardsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DebitCardsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DebitCardsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DebitCards numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DebitCardsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(debitcards.FieldUserID) {
		fields = append(fields, debitcards.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DebitCardsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DebitCardsMutation) ClearField(name string) error {
	switch name {
	case debitcards.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown DebitCards nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DebitCardsMutation) ResetField(name string) error {
	switch name {
	case debitcards.FieldUserID:
		m.ResetUserID()
		return nil
	case debitcards.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown DebitCards field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DebitCardsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.debit_card_design != nil {
		edges = append(edges, debitcards.EdgeDebitCardDesign)
	}
	if m.debit_card_details != nil {
		edges = append(edges, debitcards.EdgeDebitCardDetails)
	}
	if m.debit_card_status != nil {
		edges = append(edges, debitcards.EdgeDebitCardStatus)
	}
	if m.users != nil {
		edges = append(edges, debitcards.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DebitCardsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case debitcards.EdgeDebitCardDesign:
		ids := make([]ent.Value, 0, len(m.debit_card_design))
		for id := range m.debit_card_design {
			ids = append(ids, id)
		}
		return ids
	case debitcards.EdgeDebitCardDetails:
		ids := make([]ent.Value, 0, len(m.debit_card_details))
		for id := range m.debit_card_details {
			ids = append(ids, id)
		}
		return ids
	case debitcards.EdgeDebitCardStatus:
		ids := make([]ent.Value, 0, len(m.debit_card_status))
		for id := range m.debit_card_status {
			ids = append(ids, id)
		}
		return ids
	case debitcards.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DebitCardsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddebit_card_design != nil {
		edges = append(edges, debitcards.EdgeDebitCardDesign)
	}
	if m.removeddebit_card_details != nil {
		edges = append(edges, debitcards.EdgeDebitCardDetails)
	}
	if m.removeddebit_card_status != nil {
		edges = append(edges, debitcards.EdgeDebitCardStatus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DebitCardsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case debitcards.EdgeDebitCardDesign:
		ids := make([]ent.Value, 0, len(m.removeddebit_card_design))
		for id := range m.removeddebit_card_design {
			ids = append(ids, id)
		}
		return ids
	case debitcards.EdgeDebitCardDetails:
		ids := make([]ent.Value, 0, len(m.removeddebit_card_details))
		for id := range m.removeddebit_card_details {
			ids = append(ids, id)
		}
		return ids
	case debitcards.EdgeDebitCardStatus:
		ids := make([]ent.Value, 0, len(m.removeddebit_card_status))
		for id := range m.removeddebit_card_status {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DebitCardsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddebit_card_design {
		edges = append(edges, debitcards.EdgeDebitCardDesign)
	}
	if m.cleareddebit_card_details {
		edges = append(edges, debitcards.EdgeDebitCardDetails)
	}
	if m.cleareddebit_card_status {
		edges = append(edges, debitcards.EdgeDebitCardStatus)
	}
	if m.clearedusers {
		edges = append(edges, debitcards.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DebitCardsMutation) EdgeCleared(name string) bool {
	switch name {
	case debitcards.EdgeDebitCardDesign:
		return m.cleareddebit_card_design
	case debitcards.EdgeDebitCardDetails:
		return m.cleareddebit_card_details
	case debitcards.EdgeDebitCardStatus:
		return m.cleareddebit_card_status
	case debitcards.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DebitCardsMutation) ClearEdge(name string) error {
	switch name {
	case debitcards.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown DebitCards unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DebitCardsMutation) ResetEdge(name string) error {
	switch name {
	case debitcards.EdgeDebitCardDesign:
		m.ResetDebitCardDesign()
		return nil
	case debitcards.EdgeDebitCardDetails:
		m.ResetDebitCardDetails()
		return nil
	case debitcards.EdgeDebitCardStatus:
		m.ResetDebitCardStatus()
		return nil
	case debitcards.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown DebitCards edge %s", name)
}

// TransactionsMutation represents an operation that mutates the Transactions nodes in the graph.
type TransactionsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	image         *string
	isBank        *bool
	clearedFields map[string]struct{}
	users         *int
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Transactions, error)
	predicates    []predicate.Transactions
}

var _ ent.Mutation = (*TransactionsMutation)(nil)

// transactionsOption allows management of the mutation configuration using functional options.
type transactionsOption func(*TransactionsMutation)

// newTransactionsMutation creates new mutation for the Transactions entity.
func newTransactionsMutation(c config, op Op, opts ...transactionsOption) *TransactionsMutation {
	m := &TransactionsMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionsID sets the ID field of the mutation.
func withTransactionsID(id int) transactionsOption {
	return func(m *TransactionsMutation) {
		var (
			err   error
			once  sync.Once
			value *Transactions
		)
		m.oldValue = func(ctx context.Context) (*Transactions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transactions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactions sets the old Transactions of the mutation.
func withTransactions(node *Transactions) transactionsOption {
	return func(m *TransactionsMutation) {
		m.oldValue = func(context.Context) (*Transactions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transactions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *TransactionsMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TransactionsMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Transactions entity.
// If the Transactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *TransactionsMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[transactions.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TransactionsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[transactions.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TransactionsMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, transactions.FieldUserID)
}

// SetName sets the "name" field.
func (m *TransactionsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TransactionsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Transactions entity.
// If the Transactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TransactionsMutation) ResetName() {
	m.name = nil
}

// SetImage sets the "image" field.
func (m *TransactionsMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *TransactionsMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Transactions entity.
// If the Transactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionsMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *TransactionsMutation) ResetImage() {
	m.image = nil
}

// SetIsBank sets the "isBank" field.
func (m *TransactionsMutation) SetIsBank(b bool) {
	m.isBank = &b
}

// IsBank returns the value of the "isBank" field in the mutation.
func (m *TransactionsMutation) IsBank() (r bool, exists bool) {
	v := m.isBank
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBank returns the old "isBank" field's value of the Transactions entity.
// If the Transactions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionsMutation) OldIsBank(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBank: %w", err)
	}
	return oldValue.IsBank, nil
}

// ResetIsBank resets all changes to the "isBank" field.
func (m *TransactionsMutation) ResetIsBank() {
	m.isBank = nil
}

// SetUsersID sets the "users" edge to the Users entity by id.
func (m *TransactionsMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *TransactionsMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[transactions.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *TransactionsMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *TransactionsMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *TransactionsMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *TransactionsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the TransactionsMutation builder.
func (m *TransactionsMutation) Where(ps ...predicate.Transactions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transactions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transactions).
func (m *TransactionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.users != nil {
		fields = append(fields, transactions.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, transactions.FieldName)
	}
	if m.image != nil {
		fields = append(fields, transactions.FieldImage)
	}
	if m.isBank != nil {
		fields = append(fields, transactions.FieldIsBank)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactions.FieldUserID:
		return m.UserID()
	case transactions.FieldName:
		return m.Name()
	case transactions.FieldImage:
		return m.Image()
	case transactions.FieldIsBank:
		return m.IsBank()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactions.FieldUserID:
		return m.OldUserID(ctx)
	case transactions.FieldName:
		return m.OldName(ctx)
	case transactions.FieldImage:
		return m.OldImage(ctx)
	case transactions.FieldIsBank:
		return m.OldIsBank(ctx)
	}
	return nil, fmt.Errorf("unknown Transactions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactions.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case transactions.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case transactions.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case transactions.FieldIsBank:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBank(v)
		return nil
	}
	return fmt.Errorf("unknown Transactions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Transactions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transactions.FieldUserID) {
		fields = append(fields, transactions.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionsMutation) ClearField(name string) error {
	switch name {
	case transactions.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Transactions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionsMutation) ResetField(name string) error {
	switch name {
	case transactions.FieldUserID:
		m.ResetUserID()
		return nil
	case transactions.FieldName:
		m.ResetName()
		return nil
	case transactions.FieldImage:
		m.ResetImage()
		return nil
	case transactions.FieldIsBank:
		m.ResetIsBank()
		return nil
	}
	return fmt.Errorf("unknown Transactions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, transactions.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactions.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, transactions.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionsMutation) EdgeCleared(name string) bool {
	switch name {
	case transactions.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionsMutation) ClearEdge(name string) error {
	switch name {
	case transactions.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown Transactions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionsMutation) ResetEdge(name string) error {
	switch name {
	case transactions.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Transactions edge %s", name)
}

// UserGreetingsMutation represents an operation that mutates the UserGreetings nodes in the graph.
type UserGreetingsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	greeting      *string
	clearedFields map[string]struct{}
	users         *int
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*UserGreetings, error)
	predicates    []predicate.UserGreetings
}

var _ ent.Mutation = (*UserGreetingsMutation)(nil)

// usergreetingsOption allows management of the mutation configuration using functional options.
type usergreetingsOption func(*UserGreetingsMutation)

// newUserGreetingsMutation creates new mutation for the UserGreetings entity.
func newUserGreetingsMutation(c config, op Op, opts ...usergreetingsOption) *UserGreetingsMutation {
	m := &UserGreetingsMutation{
		config:        c,
		op:            op,
		typ:           TypeUserGreetings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserGreetingsID sets the ID field of the mutation.
func withUserGreetingsID(id int) usergreetingsOption {
	return func(m *UserGreetingsMutation) {
		var (
			err   error
			once  sync.Once
			value *UserGreetings
		)
		m.oldValue = func(ctx context.Context) (*UserGreetings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserGreetings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserGreetings sets the old UserGreetings of the mutation.
func withUserGreetings(node *UserGreetings) usergreetingsOption {
	return func(m *UserGreetingsMutation) {
		m.oldValue = func(context.Context) (*UserGreetings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserGreetingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserGreetingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserGreetingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserGreetingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserGreetings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserGreetingsMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserGreetingsMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserGreetings entity.
// If the UserGreetings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGreetingsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserGreetingsMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[usergreetings.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserGreetingsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usergreetings.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserGreetingsMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, usergreetings.FieldUserID)
}

// SetGreeting sets the "greeting" field.
func (m *UserGreetingsMutation) SetGreeting(s string) {
	m.greeting = &s
}

// Greeting returns the value of the "greeting" field in the mutation.
func (m *UserGreetingsMutation) Greeting() (r string, exists bool) {
	v := m.greeting
	if v == nil {
		return
	}
	return *v, true
}

// OldGreeting returns the old "greeting" field's value of the UserGreetings entity.
// If the UserGreetings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserGreetingsMutation) OldGreeting(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGreeting is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGreeting requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGreeting: %w", err)
	}
	return oldValue.Greeting, nil
}

// ResetGreeting resets all changes to the "greeting" field.
func (m *UserGreetingsMutation) ResetGreeting() {
	m.greeting = nil
}

// SetUsersID sets the "users" edge to the Users entity by id.
func (m *UserGreetingsMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the Users entity.
func (m *UserGreetingsMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[usergreetings.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the Users entity was cleared.
func (m *UserGreetingsMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *UserGreetingsMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *UserGreetingsMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *UserGreetingsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the UserGreetingsMutation builder.
func (m *UserGreetingsMutation) Where(ps ...predicate.UserGreetings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserGreetingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserGreetingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserGreetings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserGreetingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserGreetingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserGreetings).
func (m *UserGreetingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserGreetingsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.users != nil {
		fields = append(fields, usergreetings.FieldUserID)
	}
	if m.greeting != nil {
		fields = append(fields, usergreetings.FieldGreeting)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserGreetingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usergreetings.FieldUserID:
		return m.UserID()
	case usergreetings.FieldGreeting:
		return m.Greeting()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserGreetingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usergreetings.FieldUserID:
		return m.OldUserID(ctx)
	case usergreetings.FieldGreeting:
		return m.OldGreeting(ctx)
	}
	return nil, fmt.Errorf("unknown UserGreetings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGreetingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usergreetings.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usergreetings.FieldGreeting:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGreeting(v)
		return nil
	}
	return fmt.Errorf("unknown UserGreetings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserGreetingsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserGreetingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserGreetingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserGreetings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserGreetingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usergreetings.FieldUserID) {
		fields = append(fields, usergreetings.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserGreetingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserGreetingsMutation) ClearField(name string) error {
	switch name {
	case usergreetings.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown UserGreetings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserGreetingsMutation) ResetField(name string) error {
	switch name {
	case usergreetings.FieldUserID:
		m.ResetUserID()
		return nil
	case usergreetings.FieldGreeting:
		m.ResetGreeting()
		return nil
	}
	return fmt.Errorf("unknown UserGreetings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserGreetingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, usergreetings.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserGreetingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usergreetings.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserGreetingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserGreetingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserGreetingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, usergreetings.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserGreetingsMutation) EdgeCleared(name string) bool {
	switch name {
	case usergreetings.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserGreetingsMutation) ClearEdge(name string) error {
	switch name {
	case usergreetings.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown UserGreetings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserGreetingsMutation) ResetEdge(name string) error {
	switch name {
	case usergreetings.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown UserGreetings edge %s", name)
}

// UsersMutation represents an operation that mutates the Users nodes in the graph.
type UsersMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	image_url                 *string
	clearedFields             map[string]struct{}
	accounts                  map[int]struct{}
	removedaccounts           map[int]struct{}
	clearedaccounts           bool
	banners                   map[int]struct{}
	removedbanners            map[int]struct{}
	clearedbanners            bool
	debit_cards               map[int]struct{}
	removeddebit_cards        map[int]struct{}
	cleareddebit_cards        bool
	transactions              map[int]struct{}
	removedtransactions       map[int]struct{}
	clearedtransactions       bool
	user_greetings            map[int]struct{}
	removeduser_greetings     map[int]struct{}
	cleareduser_greetings     bool
	account_balances          map[int]struct{}
	removedaccount_balances   map[int]struct{}
	clearedaccount_balances   bool
	account_details           map[int]struct{}
	removedaccount_details    map[int]struct{}
	clearedaccount_details    bool
	account_flags             map[int]struct{}
	removedaccount_flags      map[int]struct{}
	clearedaccount_flags      bool
	debit_card_design         map[int]struct{}
	removeddebit_card_design  map[int]struct{}
	cleareddebit_card_design  bool
	debit_card_details        map[int]struct{}
	removeddebit_card_details map[int]struct{}
	cleareddebit_card_details bool
	debit_card_status         map[int]struct{}
	removeddebit_card_status  map[int]struct{}
	cleareddebit_card_status  bool
	done                      bool
	oldValue                  func(context.Context) (*Users, error)
	predicates                []predicate.Users
}

var _ ent.Mutation = (*UsersMutation)(nil)

// usersOption allows management of the mutation configuration using functional options.
type usersOption func(*UsersMutation)

// newUsersMutation creates new mutation for the Users entity.
func newUsersMutation(c config, op Op, opts ...usersOption) *UsersMutation {
	m := &UsersMutation{
		config:        c,
		op:            op,
		typ:           TypeUsers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsersID sets the ID field of the mutation.
func withUsersID(id int) usersOption {
	return func(m *UsersMutation) {
		var (
			err   error
			once  sync.Once
			value *Users
		)
		m.oldValue = func(ctx context.Context) (*Users, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Users.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsers sets the old Users of the mutation.
func withUsers(node *Users) usersOption {
	return func(m *UsersMutation) {
		m.oldValue = func(context.Context) (*Users, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsersMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Users.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UsersMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UsersMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UsersMutation) ResetName() {
	m.name = nil
}

// SetImageURL sets the "image_url" field.
func (m *UsersMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *UsersMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Users entity.
// If the Users object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *UsersMutation) ResetImageURL() {
	m.image_url = nil
}

// AddAccountIDs adds the "accounts" edge to the Accounts entity by ids.
func (m *UsersMutation) AddAccountIDs(ids ...int) {
	if m.accounts == nil {
		m.accounts = make(map[int]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Accounts entity.
func (m *UsersMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Accounts entity was cleared.
func (m *UsersMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Accounts entity by IDs.
func (m *UsersMutation) RemoveAccountIDs(ids ...int) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Accounts entity.
func (m *UsersMutation) RemovedAccountsIDs() (ids []int) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *UsersMutation) AccountsIDs() (ids []int) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *UsersMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddBannerIDs adds the "banners" edge to the Banners entity by ids.
func (m *UsersMutation) AddBannerIDs(ids ...int) {
	if m.banners == nil {
		m.banners = make(map[int]struct{})
	}
	for i := range ids {
		m.banners[ids[i]] = struct{}{}
	}
}

// ClearBanners clears the "banners" edge to the Banners entity.
func (m *UsersMutation) ClearBanners() {
	m.clearedbanners = true
}

// BannersCleared reports if the "banners" edge to the Banners entity was cleared.
func (m *UsersMutation) BannersCleared() bool {
	return m.clearedbanners
}

// RemoveBannerIDs removes the "banners" edge to the Banners entity by IDs.
func (m *UsersMutation) RemoveBannerIDs(ids ...int) {
	if m.removedbanners == nil {
		m.removedbanners = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.banners, ids[i])
		m.removedbanners[ids[i]] = struct{}{}
	}
}

// RemovedBanners returns the removed IDs of the "banners" edge to the Banners entity.
func (m *UsersMutation) RemovedBannersIDs() (ids []int) {
	for id := range m.removedbanners {
		ids = append(ids, id)
	}
	return
}

// BannersIDs returns the "banners" edge IDs in the mutation.
func (m *UsersMutation) BannersIDs() (ids []int) {
	for id := range m.banners {
		ids = append(ids, id)
	}
	return
}

// ResetBanners resets all changes to the "banners" edge.
func (m *UsersMutation) ResetBanners() {
	m.banners = nil
	m.clearedbanners = false
	m.removedbanners = nil
}

// AddDebitCardIDs adds the "debit_cards" edge to the DebitCards entity by ids.
func (m *UsersMutation) AddDebitCardIDs(ids ...int) {
	if m.debit_cards == nil {
		m.debit_cards = make(map[int]struct{})
	}
	for i := range ids {
		m.debit_cards[ids[i]] = struct{}{}
	}
}

// ClearDebitCards clears the "debit_cards" edge to the DebitCards entity.
func (m *UsersMutation) ClearDebitCards() {
	m.cleareddebit_cards = true
}

// DebitCardsCleared reports if the "debit_cards" edge to the DebitCards entity was cleared.
func (m *UsersMutation) DebitCardsCleared() bool {
	return m.cleareddebit_cards
}

// RemoveDebitCardIDs removes the "debit_cards" edge to the DebitCards entity by IDs.
func (m *UsersMutation) RemoveDebitCardIDs(ids ...int) {
	if m.removeddebit_cards == nil {
		m.removeddebit_cards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.debit_cards, ids[i])
		m.removeddebit_cards[ids[i]] = struct{}{}
	}
}

// RemovedDebitCards returns the removed IDs of the "debit_cards" edge to the DebitCards entity.
func (m *UsersMutation) RemovedDebitCardsIDs() (ids []int) {
	for id := range m.removeddebit_cards {
		ids = append(ids, id)
	}
	return
}

// DebitCardsIDs returns the "debit_cards" edge IDs in the mutation.
func (m *UsersMutation) DebitCardsIDs() (ids []int) {
	for id := range m.debit_cards {
		ids = append(ids, id)
	}
	return
}

// ResetDebitCards resets all changes to the "debit_cards" edge.
func (m *UsersMutation) ResetDebitCards() {
	m.debit_cards = nil
	m.cleareddebit_cards = false
	m.removeddebit_cards = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transactions entity by ids.
func (m *UsersMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transactions entity.
func (m *UsersMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transactions entity was cleared.
func (m *UsersMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transactions entity by IDs.
func (m *UsersMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transactions entity.
func (m *UsersMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *UsersMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *UsersMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddUserGreetingIDs adds the "user_greetings" edge to the UserGreetings entity by ids.
func (m *UsersMutation) AddUserGreetingIDs(ids ...int) {
	if m.user_greetings == nil {
		m.user_greetings = make(map[int]struct{})
	}
	for i := range ids {
		m.user_greetings[ids[i]] = struct{}{}
	}
}

// ClearUserGreetings clears the "user_greetings" edge to the UserGreetings entity.
func (m *UsersMutation) ClearUserGreetings() {
	m.cleareduser_greetings = true
}

// UserGreetingsCleared reports if the "user_greetings" edge to the UserGreetings entity was cleared.
func (m *UsersMutation) UserGreetingsCleared() bool {
	return m.cleareduser_greetings
}

// RemoveUserGreetingIDs removes the "user_greetings" edge to the UserGreetings entity by IDs.
func (m *UsersMutation) RemoveUserGreetingIDs(ids ...int) {
	if m.removeduser_greetings == nil {
		m.removeduser_greetings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_greetings, ids[i])
		m.removeduser_greetings[ids[i]] = struct{}{}
	}
}

// RemovedUserGreetings returns the removed IDs of the "user_greetings" edge to the UserGreetings entity.
func (m *UsersMutation) RemovedUserGreetingsIDs() (ids []int) {
	for id := range m.removeduser_greetings {
		ids = append(ids, id)
	}
	return
}

// UserGreetingsIDs returns the "user_greetings" edge IDs in the mutation.
func (m *UsersMutation) UserGreetingsIDs() (ids []int) {
	for id := range m.user_greetings {
		ids = append(ids, id)
	}
	return
}

// ResetUserGreetings resets all changes to the "user_greetings" edge.
func (m *UsersMutation) ResetUserGreetings() {
	m.user_greetings = nil
	m.cleareduser_greetings = false
	m.removeduser_greetings = nil
}

// AddAccountBalanceIDs adds the "account_balances" edge to the AccountBalances entity by ids.
func (m *UsersMutation) AddAccountBalanceIDs(ids ...int) {
	if m.account_balances == nil {
		m.account_balances = make(map[int]struct{})
	}
	for i := range ids {
		m.account_balances[ids[i]] = struct{}{}
	}
}

// ClearAccountBalances clears the "account_balances" edge to the AccountBalances entity.
func (m *UsersMutation) ClearAccountBalances() {
	m.clearedaccount_balances = true
}

// AccountBalancesCleared reports if the "account_balances" edge to the AccountBalances entity was cleared.
func (m *UsersMutation) AccountBalancesCleared() bool {
	return m.clearedaccount_balances
}

// RemoveAccountBalanceIDs removes the "account_balances" edge to the AccountBalances entity by IDs.
func (m *UsersMutation) RemoveAccountBalanceIDs(ids ...int) {
	if m.removedaccount_balances == nil {
		m.removedaccount_balances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.account_balances, ids[i])
		m.removedaccount_balances[ids[i]] = struct{}{}
	}
}

// RemovedAccountBalances returns the removed IDs of the "account_balances" edge to the AccountBalances entity.
func (m *UsersMutation) RemovedAccountBalancesIDs() (ids []int) {
	for id := range m.removedaccount_balances {
		ids = append(ids, id)
	}
	return
}

// AccountBalancesIDs returns the "account_balances" edge IDs in the mutation.
func (m *UsersMutation) AccountBalancesIDs() (ids []int) {
	for id := range m.account_balances {
		ids = append(ids, id)
	}
	return
}

// ResetAccountBalances resets all changes to the "account_balances" edge.
func (m *UsersMutation) ResetAccountBalances() {
	m.account_balances = nil
	m.clearedaccount_balances = false
	m.removedaccount_balances = nil
}

// AddAccountDetailIDs adds the "account_details" edge to the AccountDetails entity by ids.
func (m *UsersMutation) AddAccountDetailIDs(ids ...int) {
	if m.account_details == nil {
		m.account_details = make(map[int]struct{})
	}
	for i := range ids {
		m.account_details[ids[i]] = struct{}{}
	}
}

// ClearAccountDetails clears the "account_details" edge to the AccountDetails entity.
func (m *UsersMutation) ClearAccountDetails() {
	m.clearedaccount_details = true
}

// AccountDetailsCleared reports if the "account_details" edge to the AccountDetails entity was cleared.
func (m *UsersMutation) AccountDetailsCleared() bool {
	return m.clearedaccount_details
}

// RemoveAccountDetailIDs removes the "account_details" edge to the AccountDetails entity by IDs.
func (m *UsersMutation) RemoveAccountDetailIDs(ids ...int) {
	if m.removedaccount_details == nil {
		m.removedaccount_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.account_details, ids[i])
		m.removedaccount_details[ids[i]] = struct{}{}
	}
}

// RemovedAccountDetails returns the removed IDs of the "account_details" edge to the AccountDetails entity.
func (m *UsersMutation) RemovedAccountDetailsIDs() (ids []int) {
	for id := range m.removedaccount_details {
		ids = append(ids, id)
	}
	return
}

// AccountDetailsIDs returns the "account_details" edge IDs in the mutation.
func (m *UsersMutation) AccountDetailsIDs() (ids []int) {
	for id := range m.account_details {
		ids = append(ids, id)
	}
	return
}

// ResetAccountDetails resets all changes to the "account_details" edge.
func (m *UsersMutation) ResetAccountDetails() {
	m.account_details = nil
	m.clearedaccount_details = false
	m.removedaccount_details = nil
}

// AddAccountFlagIDs adds the "account_flags" edge to the AccountFlags entity by ids.
func (m *UsersMutation) AddAccountFlagIDs(ids ...int) {
	if m.account_flags == nil {
		m.account_flags = make(map[int]struct{})
	}
	for i := range ids {
		m.account_flags[ids[i]] = struct{}{}
	}
}

// ClearAccountFlags clears the "account_flags" edge to the AccountFlags entity.
func (m *UsersMutation) ClearAccountFlags() {
	m.clearedaccount_flags = true
}

// AccountFlagsCleared reports if the "account_flags" edge to the AccountFlags entity was cleared.
func (m *UsersMutation) AccountFlagsCleared() bool {
	return m.clearedaccount_flags
}

// RemoveAccountFlagIDs removes the "account_flags" edge to the AccountFlags entity by IDs.
func (m *UsersMutation) RemoveAccountFlagIDs(ids ...int) {
	if m.removedaccount_flags == nil {
		m.removedaccount_flags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.account_flags, ids[i])
		m.removedaccount_flags[ids[i]] = struct{}{}
	}
}

// RemovedAccountFlags returns the removed IDs of the "account_flags" edge to the AccountFlags entity.
func (m *UsersMutation) RemovedAccountFlagsIDs() (ids []int) {
	for id := range m.removedaccount_flags {
		ids = append(ids, id)
	}
	return
}

// AccountFlagsIDs returns the "account_flags" edge IDs in the mutation.
func (m *UsersMutation) AccountFlagsIDs() (ids []int) {
	for id := range m.account_flags {
		ids = append(ids, id)
	}
	return
}

// ResetAccountFlags resets all changes to the "account_flags" edge.
func (m *UsersMutation) ResetAccountFlags() {
	m.account_flags = nil
	m.clearedaccount_flags = false
	m.removedaccount_flags = nil
}

// AddDebitCardDesignIDs adds the "debit_card_design" edge to the DebitCardDesign entity by ids.
func (m *UsersMutation) AddDebitCardDesignIDs(ids ...int) {
	if m.debit_card_design == nil {
		m.debit_card_design = make(map[int]struct{})
	}
	for i := range ids {
		m.debit_card_design[ids[i]] = struct{}{}
	}
}

// ClearDebitCardDesign clears the "debit_card_design" edge to the DebitCardDesign entity.
func (m *UsersMutation) ClearDebitCardDesign() {
	m.cleareddebit_card_design = true
}

// DebitCardDesignCleared reports if the "debit_card_design" edge to the DebitCardDesign entity was cleared.
func (m *UsersMutation) DebitCardDesignCleared() bool {
	return m.cleareddebit_card_design
}

// RemoveDebitCardDesignIDs removes the "debit_card_design" edge to the DebitCardDesign entity by IDs.
func (m *UsersMutation) RemoveDebitCardDesignIDs(ids ...int) {
	if m.removeddebit_card_design == nil {
		m.removeddebit_card_design = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.debit_card_design, ids[i])
		m.removeddebit_card_design[ids[i]] = struct{}{}
	}
}

// RemovedDebitCardDesign returns the removed IDs of the "debit_card_design" edge to the DebitCardDesign entity.
func (m *UsersMutation) RemovedDebitCardDesignIDs() (ids []int) {
	for id := range m.removeddebit_card_design {
		ids = append(ids, id)
	}
	return
}

// DebitCardDesignIDs returns the "debit_card_design" edge IDs in the mutation.
func (m *UsersMutation) DebitCardDesignIDs() (ids []int) {
	for id := range m.debit_card_design {
		ids = append(ids, id)
	}
	return
}

// ResetDebitCardDesign resets all changes to the "debit_card_design" edge.
func (m *UsersMutation) ResetDebitCardDesign() {
	m.debit_card_design = nil
	m.cleareddebit_card_design = false
	m.removeddebit_card_design = nil
}

// AddDebitCardDetailIDs adds the "debit_card_details" edge to the DebitCardDetails entity by ids.
func (m *UsersMutation) AddDebitCardDetailIDs(ids ...int) {
	if m.debit_card_details == nil {
		m.debit_card_details = make(map[int]struct{})
	}
	for i := range ids {
		m.debit_card_details[ids[i]] = struct{}{}
	}
}

// ClearDebitCardDetails clears the "debit_card_details" edge to the DebitCardDetails entity.
func (m *UsersMutation) ClearDebitCardDetails() {
	m.cleareddebit_card_details = true
}

// DebitCardDetailsCleared reports if the "debit_card_details" edge to the DebitCardDetails entity was cleared.
func (m *UsersMutation) DebitCardDetailsCleared() bool {
	return m.cleareddebit_card_details
}

// RemoveDebitCardDetailIDs removes the "debit_card_details" edge to the DebitCardDetails entity by IDs.
func (m *UsersMutation) RemoveDebitCardDetailIDs(ids ...int) {
	if m.removeddebit_card_details == nil {
		m.removeddebit_card_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.debit_card_details, ids[i])
		m.removeddebit_card_details[ids[i]] = struct{}{}
	}
}

// RemovedDebitCardDetails returns the removed IDs of the "debit_card_details" edge to the DebitCardDetails entity.
func (m *UsersMutation) RemovedDebitCardDetailsIDs() (ids []int) {
	for id := range m.removeddebit_card_details {
		ids = append(ids, id)
	}
	return
}

// DebitCardDetailsIDs returns the "debit_card_details" edge IDs in the mutation.
func (m *UsersMutation) DebitCardDetailsIDs() (ids []int) {
	for id := range m.debit_card_details {
		ids = append(ids, id)
	}
	return
}

// ResetDebitCardDetails resets all changes to the "debit_card_details" edge.
func (m *UsersMutation) ResetDebitCardDetails() {
	m.debit_card_details = nil
	m.cleareddebit_card_details = false
	m.removeddebit_card_details = nil
}

// AddDebitCardStatuIDs adds the "debit_card_status" edge to the DebitCardStatus entity by ids.
func (m *UsersMutation) AddDebitCardStatuIDs(ids ...int) {
	if m.debit_card_status == nil {
		m.debit_card_status = make(map[int]struct{})
	}
	for i := range ids {
		m.debit_card_status[ids[i]] = struct{}{}
	}
}

// ClearDebitCardStatus clears the "debit_card_status" edge to the DebitCardStatus entity.
func (m *UsersMutation) ClearDebitCardStatus() {
	m.cleareddebit_card_status = true
}

// DebitCardStatusCleared reports if the "debit_card_status" edge to the DebitCardStatus entity was cleared.
func (m *UsersMutation) DebitCardStatusCleared() bool {
	return m.cleareddebit_card_status
}

// RemoveDebitCardStatuIDs removes the "debit_card_status" edge to the DebitCardStatus entity by IDs.
func (m *UsersMutation) RemoveDebitCardStatuIDs(ids ...int) {
	if m.removeddebit_card_status == nil {
		m.removeddebit_card_status = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.debit_card_status, ids[i])
		m.removeddebit_card_status[ids[i]] = struct{}{}
	}
}

// RemovedDebitCardStatus returns the removed IDs of the "debit_card_status" edge to the DebitCardStatus entity.
func (m *UsersMutation) RemovedDebitCardStatusIDs() (ids []int) {
	for id := range m.removeddebit_card_status {
		ids = append(ids, id)
	}
	return
}

// DebitCardStatusIDs returns the "debit_card_status" edge IDs in the mutation.
func (m *UsersMutation) DebitCardStatusIDs() (ids []int) {
	for id := range m.debit_card_status {
		ids = append(ids, id)
	}
	return
}

// ResetDebitCardStatus resets all changes to the "debit_card_status" edge.
func (m *UsersMutation) ResetDebitCardStatus() {
	m.debit_card_status = nil
	m.cleareddebit_card_status = false
	m.removeddebit_card_status = nil
}

// Where appends a list predicates to the UsersMutation builder.
func (m *UsersMutation) Where(ps ...predicate.Users) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Users, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Users).
func (m *UsersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsersMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, users.FieldName)
	}
	if m.image_url != nil {
		fields = append(fields, users.FieldImageURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case users.FieldName:
		return m.Name()
	case users.FieldImageURL:
		return m.ImageURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case users.FieldName:
		return m.OldName(ctx)
	case users.FieldImageURL:
		return m.OldImageURL(ctx)
	}
	return nil, fmt.Errorf("unknown Users field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case users.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case users.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	}
	return fmt.Errorf("unknown Users field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsersMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsersMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Users numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsersMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsersMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Users nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsersMutation) ResetField(name string) error {
	switch name {
	case users.FieldName:
		m.ResetName()
		return nil
	case users.FieldImageURL:
		m.ResetImageURL()
		return nil
	}
	return fmt.Errorf("unknown Users field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsersMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.accounts != nil {
		edges = append(edges, users.EdgeAccounts)
	}
	if m.banners != nil {
		edges = append(edges, users.EdgeBanners)
	}
	if m.debit_cards != nil {
		edges = append(edges, users.EdgeDebitCards)
	}
	if m.transactions != nil {
		edges = append(edges, users.EdgeTransactions)
	}
	if m.user_greetings != nil {
		edges = append(edges, users.EdgeUserGreetings)
	}
	if m.account_balances != nil {
		edges = append(edges, users.EdgeAccountBalances)
	}
	if m.account_details != nil {
		edges = append(edges, users.EdgeAccountDetails)
	}
	if m.account_flags != nil {
		edges = append(edges, users.EdgeAccountFlags)
	}
	if m.debit_card_design != nil {
		edges = append(edges, users.EdgeDebitCardDesign)
	}
	if m.debit_card_details != nil {
		edges = append(edges, users.EdgeDebitCardDetails)
	}
	if m.debit_card_status != nil {
		edges = append(edges, users.EdgeDebitCardStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case users.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.banners))
		for id := range m.banners {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeDebitCards:
		ids := make([]ent.Value, 0, len(m.debit_cards))
		for id := range m.debit_cards {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeUserGreetings:
		ids := make([]ent.Value, 0, len(m.user_greetings))
		for id := range m.user_greetings {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeAccountBalances:
		ids := make([]ent.Value, 0, len(m.account_balances))
		for id := range m.account_balances {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeAccountDetails:
		ids := make([]ent.Value, 0, len(m.account_details))
		for id := range m.account_details {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeAccountFlags:
		ids := make([]ent.Value, 0, len(m.account_flags))
		for id := range m.account_flags {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeDebitCardDesign:
		ids := make([]ent.Value, 0, len(m.debit_card_design))
		for id := range m.debit_card_design {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeDebitCardDetails:
		ids := make([]ent.Value, 0, len(m.debit_card_details))
		for id := range m.debit_card_details {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeDebitCardStatus:
		ids := make([]ent.Value, 0, len(m.debit_card_status))
		for id := range m.debit_card_status {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedaccounts != nil {
		edges = append(edges, users.EdgeAccounts)
	}
	if m.removedbanners != nil {
		edges = append(edges, users.EdgeBanners)
	}
	if m.removeddebit_cards != nil {
		edges = append(edges, users.EdgeDebitCards)
	}
	if m.removedtransactions != nil {
		edges = append(edges, users.EdgeTransactions)
	}
	if m.removeduser_greetings != nil {
		edges = append(edges, users.EdgeUserGreetings)
	}
	if m.removedaccount_balances != nil {
		edges = append(edges, users.EdgeAccountBalances)
	}
	if m.removedaccount_details != nil {
		edges = append(edges, users.EdgeAccountDetails)
	}
	if m.removedaccount_flags != nil {
		edges = append(edges, users.EdgeAccountFlags)
	}
	if m.removeddebit_card_design != nil {
		edges = append(edges, users.EdgeDebitCardDesign)
	}
	if m.removeddebit_card_details != nil {
		edges = append(edges, users.EdgeDebitCardDetails)
	}
	if m.removeddebit_card_status != nil {
		edges = append(edges, users.EdgeDebitCardStatus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsersMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case users.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.removedbanners))
		for id := range m.removedbanners {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeDebitCards:
		ids := make([]ent.Value, 0, len(m.removeddebit_cards))
		for id := range m.removeddebit_cards {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeUserGreetings:
		ids := make([]ent.Value, 0, len(m.removeduser_greetings))
		for id := range m.removeduser_greetings {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeAccountBalances:
		ids := make([]ent.Value, 0, len(m.removedaccount_balances))
		for id := range m.removedaccount_balances {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeAccountDetails:
		ids := make([]ent.Value, 0, len(m.removedaccount_details))
		for id := range m.removedaccount_details {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeAccountFlags:
		ids := make([]ent.Value, 0, len(m.removedaccount_flags))
		for id := range m.removedaccount_flags {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeDebitCardDesign:
		ids := make([]ent.Value, 0, len(m.removeddebit_card_design))
		for id := range m.removeddebit_card_design {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeDebitCardDetails:
		ids := make([]ent.Value, 0, len(m.removeddebit_card_details))
		for id := range m.removeddebit_card_details {
			ids = append(ids, id)
		}
		return ids
	case users.EdgeDebitCardStatus:
		ids := make([]ent.Value, 0, len(m.removeddebit_card_status))
		for id := range m.removeddebit_card_status {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedaccounts {
		edges = append(edges, users.EdgeAccounts)
	}
	if m.clearedbanners {
		edges = append(edges, users.EdgeBanners)
	}
	if m.cleareddebit_cards {
		edges = append(edges, users.EdgeDebitCards)
	}
	if m.clearedtransactions {
		edges = append(edges, users.EdgeTransactions)
	}
	if m.cleareduser_greetings {
		edges = append(edges, users.EdgeUserGreetings)
	}
	if m.clearedaccount_balances {
		edges = append(edges, users.EdgeAccountBalances)
	}
	if m.clearedaccount_details {
		edges = append(edges, users.EdgeAccountDetails)
	}
	if m.clearedaccount_flags {
		edges = append(edges, users.EdgeAccountFlags)
	}
	if m.cleareddebit_card_design {
		edges = append(edges, users.EdgeDebitCardDesign)
	}
	if m.cleareddebit_card_details {
		edges = append(edges, users.EdgeDebitCardDetails)
	}
	if m.cleareddebit_card_status {
		edges = append(edges, users.EdgeDebitCardStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsersMutation) EdgeCleared(name string) bool {
	switch name {
	case users.EdgeAccounts:
		return m.clearedaccounts
	case users.EdgeBanners:
		return m.clearedbanners
	case users.EdgeDebitCards:
		return m.cleareddebit_cards
	case users.EdgeTransactions:
		return m.clearedtransactions
	case users.EdgeUserGreetings:
		return m.cleareduser_greetings
	case users.EdgeAccountBalances:
		return m.clearedaccount_balances
	case users.EdgeAccountDetails:
		return m.clearedaccount_details
	case users.EdgeAccountFlags:
		return m.clearedaccount_flags
	case users.EdgeDebitCardDesign:
		return m.cleareddebit_card_design
	case users.EdgeDebitCardDetails:
		return m.cleareddebit_card_details
	case users.EdgeDebitCardStatus:
		return m.cleareddebit_card_status
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsersMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Users unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsersMutation) ResetEdge(name string) error {
	switch name {
	case users.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case users.EdgeBanners:
		m.ResetBanners()
		return nil
	case users.EdgeDebitCards:
		m.ResetDebitCards()
		return nil
	case users.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case users.EdgeUserGreetings:
		m.ResetUserGreetings()
		return nil
	case users.EdgeAccountBalances:
		m.ResetAccountBalances()
		return nil
	case users.EdgeAccountDetails:
		m.ResetAccountDetails()
		return nil
	case users.EdgeAccountFlags:
		m.ResetAccountFlags()
		return nil
	case users.EdgeDebitCardDesign:
		m.ResetDebitCardDesign()
		return nil
	case users.EdgeDebitCardDetails:
		m.ResetDebitCardDetails()
		return nil
	case users.EdgeDebitCardStatus:
		m.ResetDebitCardStatus()
		return nil
	}
	return fmt.Errorf("unknown Users edge %s", name)
}
